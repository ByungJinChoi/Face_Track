<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<title>XROBO BLE â€” ì–¼êµ´ ë°©í–¥ ì¸ì‹ Edition (ROI / 0.5ì´ˆ ì£¼ê¸°)</title>
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
<script src="https://unpkg.com/blockly/blockly.min.js"></script>
<!-- Tesseract.js (ì›ë³¸ ìœ ì§€: ë‹¤ë¥¸ ê¸°ëŠ¥ ë³€ê²½ ê¸ˆì§€ ì¡°ê±´ ì¶©ì¡±) -->
<script src="https://unpkg.com/tesseract.js@5/dist/tesseract.min.js"></script>

<!-- â˜… ì–¼êµ´ ë°©í–¥ ì¸ì‹: MediaPipe FaceMesh ì¶”ê°€ â˜… -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>

<style>

/* === ì „ì²´í™”ë©´ ì‹¤í–‰ ì‹œ: ì˜ìƒ í¬ê²Œ, ë¡œê·¸ ì¡°ê¸ˆ ì‘ê²Œ === */
#playOverlay .body{
  display:grid;
  grid-template-columns: minmax(0, 2.6fr) minmax(260px, 1fr); /* ì™¼ìª½(ì˜ìƒ) : ì˜¤ë¥¸ìª½(ë¡œê·¸) */
  gap:0;
  height:100%;
}

/* ì „ì²´í™”ë©´ ì¹´ë©”ë¼ ë˜í¼ */
#playOverlay #ovCamWrap{
  position:relative;
  width:100%;
  height:100%;
  background:#000;
  display:flex;
  align-items:center;
  justify-content:center;
}

/* ì „ì²´í™”ë©´ ì¹´ë©”ë¼ ì˜ìƒ */
#playOverlay #ovCamWrap video#eyesCam{
  width:100%;
  height:100%;
  object-fit:contain;
  background:#000;
  transform: scaleX(-1);
}

/* ì˜¤ë¥¸ìª½ ì „ì²´í™”ë©´ ë¡œê·¸ íŒ¨ë„ */
#playOverlay .ov-right-panel{
  display:flex;
  flex-direction:column;
  min-width:0;
  background:#0b0f14;
  border-left:1px solid #123;
}
#playOverlay .ov-header{
  padding:10px 12px;
  font-weight:600;
  color:#b7d7ff;
  border-bottom:1px solid #123;
}
#playOverlay .ov-log{
  flex:1 1 auto;
  overflow:auto;
  padding:10px 12px;
  font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
  font-size:13px;
  line-height:1.4;
  color:#d3e6ff;
  background:#0b0f14;
}

/* ì „ì²´í™”ë©´ìš© ì¸ì‹ íˆ¬ëª… ì‚¬ê°í˜• */
#ovCamWrap #ovFocusBox{
  position:absolute;
  left:50%;
  top:50%;
  width:70%;
  height:70%;
  max-width:90%;
  max-height:90%;
  transform: translate(-50%,-50%);
  border:2px solid rgba(255,255,255,.9);
  border-radius:10px;
  box-shadow:0 0 0 2px rgba(0,0,0,.25), 0 0 18px rgba(0,255,220,.35);
  pointer-events:none;
  z-index:1;
  opacity:.18;
}

/* ì „ì²´í™”ë©´ ë°°ì§€ (ìº  í™”ë©´ ì•„ë˜ìª½) */
#ovCamWrap #overlayDigitBadge{
  position:absolute;
  left:50%;
  transform:translateX(-50%);
  bottom:12px;
  z-index:2;
  display:inline-flex;
  align-items:center;
  gap:.55rem;
  font: 800 13px/1 system-ui;
  color:#fff;
  padding:.48rem .8rem;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.35);
  background:rgba(0,0,0,.35);
  backdrop-filter: blur(6px);
}
#overlayDigitBadge .label{
  opacity:.7;
  font-size:12px;
}
#overlayDigitBadge .value{
  font: 900 18px/1.1 ui-monospace, Menlo, Consolas, monospace;
  padding: 2px 8px;
  border-radius:8px;
  background: rgba(255,255,255,.12);
  box-shadow: 0 0 0 2px rgba(255,255,255,.18) inset;
}

/* â˜… ì–¼êµ´ ê±°ë¦¬ ì•ˆë‚´(í™”ë©´ ìœ„ìª½ ì‘ì€ ê¸€ì”¨) â˜… */
.camDistHint{
  position:absolute;
  left:50%;
  top:12px;
  transform:translateX(-50%);
  z-index:3;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  font: 700 11px/1 system-ui;
  letter-spacing:.2px;
  color:#fff;
  padding:.30rem .60rem;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.28);
  background:rgba(0,0,0,.28);
  backdrop-filter: blur(6px);
  pointer-events:none;
  opacity:.95;
}

@media (max-width:880px){
  /* ì‘ì€ í™”ë©´ì—ì„œëŠ” ìœ„:ì˜ìƒ / ì•„ë˜:ë¡œê·¸ (ë¡œê·¸ ë†’ì´ ì•½ 180~220px) */
  #playOverlay .body{
    grid-template-columns: 1fr;
    grid-template-rows: minmax(0, 1.7fr) minmax(180px, .9fr);
  }
  #playOverlay .ov-right-panel{
    border-left:none;
    border-top:1px solid #123;
  }
}

/* ëˆˆë™ì ì• ë‹ˆë©”ì´ì…˜ì€ ìˆ¨ê¸°ê³ , ROI ë°•ìŠ¤ëŠ” ì‚¬ìš© */
#eyesStage{display:none !important;}

  :root{
    --pad:10px;
    --uiScale: 1;
    --headerH: 64px;
    --btnH: 36px;
    --gap: 8px;
    --headerBgTop: #fff7ed;
    --headerBgBottom: #fffbeb;
    --headerBorder: #fed7aa;
    --logH: 180px;
    --blue: #1d4ed8;

    --handleWBase: 22;
    --handleHBase: 28;
    --triWBase:   14;
    --triHBase:   12;

    --handleW: calc(var(--handleWBase) * var(--uiScale) * 1px);
    --handleH: calc(var(--handleHBase) * var(--uiScale) * 1px);
    --triW:    calc(var(--triWBase)    * var(--uiScale) * 1px);
    --triH:    calc(var(--triHBase)    * var(--uiScale) * 1px);
    --linkBar: calc(3 * var(--uiScale) * 1px);

    --keyW: clamp(52px, 8vmin, 92px);
    --keyH: calc(var(--keyW) * 2.7);
    --keyGap: 6px;
    --keyFont: 14px;

    /* ê¸°ë³¸ ëˆˆ ë³€ìˆ˜(ì½”ë”© í™”ë©´ì—ì„œëŠ” ì‚¬ìš© ì•ˆ í•¨, ì˜¤ë²„ë ˆì´ì—ì„œë§Œ ì”€) */
    --eyesGap: 8vmin;
    --eyeSize: 42vmin;
    --pupilSize: 16vmin;
    --blinkSpeed: 180ms;
  }
  @media (max-width: 480px){
    :root{ --keyGap: 4px; --keyFont: 13px; }
  }

  *{ box-sizing:border-box; }
  html, body{ height:100%; }
  body{ margin:0; font-family:system-ui, -apple-system, Segoe UI, Roboto, sans-serif; background:#fff; }

  /* â”€â”€ í—¤ë” â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  header{
    padding: 8px 12px;
    background: linear-gradient(180deg, var(--headerBgTop), var(--headerBgBottom));
    border-bottom: 1px solid var(--headerBorder);
    position:relative; z-index:10;
  }
  #topbar{
    display:flex;
    align-items:center;
    gap: calc(var(--gap) * var(--uiScale));
    flex-wrap: wrap;
  }
  .title{
    font-weight: 800;
    letter-spacing: .2px;
    color:#7c2d12;
    margin-right: 12px;
    font-size: calc(18px * var(--uiScale));
  }
  .spacer{ flex: 1 1 auto; }

  .btn{
    height: calc(var(--btnH) * var(--uiScale));
    padding: 0 calc(12px * var(--uiScale));
    border:0;
    border-radius: calc(10px * var(--uiScale));
    display:inline-flex;
    align-items:center;
    justify-content:center;
    font-size: calc(14px * var(--uiScale));
    font-weight:600;
    box-shadow:0 2px 8px rgba(0,0,0,.08);
    background:#f3f4f6;
    color:#111827;
    cursor:pointer;
    user-select:none;
  }
  .btn.small{
    height: calc(var(--btnH) * var(--uiScale) * .85);
    padding: 0 calc(10px * var(--uiScale));
    font-size: calc(12px * var(--uiScale));
  }
  #connectToggle{ background:#2563eb; color:#fff; }
  #testBtn{ background:#0ea5e9; color:#fff; }
  #runToggle{ background:#16a34a; color:#fff; }
  #fsBtn{ background:#111827; color:#fff; }

  .state{
    display:inline-flex;
    align-items:center;
    gap:calc(6px * var(--uiScale));
    height: calc(var(--btnH) * var(--uiScale));
    padding: 0 calc(6px * var(--uiScale));
    font-size: calc(12px * var(--uiScale));
  }
  .badgeDot{
    width: calc(22px * var(--uiScale));
    height: calc(22px * var(--uiScale));
    border-radius: 50%;
    display:inline-flex;
    align-items:center;
    justify-content:center;
    font-size: calc(11px * var(--uiScale));
    font-weight:800;
    color:#fff;
    box-shadow: 0 0 0 calc(4px * var(--uiScale)) rgba(0,0,0,.06) inset;
  }
  .badgeDot.on{ background:#3b82f6; }
  .badgeDot.off{ background:#ef4444; }

  /* â”€â”€ ë ˆì´ì•„ì›ƒ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  #main{
    display:flex;
    width:100%;
    height: calc(100vh - var(--headerH));
  }
  #left{
    position:relative;
    flex:1 1 auto;
    min-width:0;
    height:100%;
    display:flex;
    overflow:visible;
  }
  #blocklyDiv{
    flex:1 1 auto;
    min-width:0;
    height:100%;
    width:100%;
  }

  #right{
    flex:0 0 40%;
    display:flex;
    flex-direction:column;
    background:#fff;
    margin:8px 8px 8px 0;
    border:1px solid #e5e7eb;
    border-left:3px solid var(--blue);
    border-radius:12px 0 0 12px;
    box-shadow:0 2px 10px rgba(0,0,0,.04);
    overflow:hidden;
    position:relative;
  }

  /* â”€â”€ ìš°ì¸¡ ìƒë‹¨: ì¹´ë©”ë¼ í”„ë¦¬ë·° â”€â”€ */
  #rightTop{
    flex:1 1 auto;
    border-bottom:1px solid #e5e7eb;
    min-height: 120px;
    background:#0b0f14;
    color:#fff;
    display:flex;
    align-items:center;
    justify-content:center;
    padding: 0;
    overflow:hidden;
  }
  .camWrap{
    position:relative;
    width:100%;
    height:100%;
    display:flex;
    align-items:center;
    justify-content:center;
    background:#000;
  }
  #camVideo{
    width:100%;
    height:100%;
    object-fit:cover;
    transform: scaleX(-1);
    background:#000;
  }
  .camUi{
    position:absolute;
    right:12px;
    top:12px;
    display:flex;
    gap:8px;
    align-items:center;
    z-index:2;
  }
  .camBadge{
    font: 700 12px/1 system-ui;
    color:#fff;
    padding:.35rem .6rem;
    border-radius:999px;
    border:1px solid rgba(255,255,255,.3);
    background:rgba(0,0,0,.35);
    backdrop-filter: blur(6px)
  }

  /* ì¸ì‹ íˆ¬ëª…ì°½ (í™”ë©´ ë©´ì ì˜ ì•½ ì ˆë°˜) */
  #focusBox{
    position:absolute;
    left:50%;
    top:50%;
    width:70%;
    height:70%;
    max-width:90%;
    max-height:90%;
    transform: translate(-50%,-50%);
    border:2px solid rgba(255,255,255,.9);
    border-radius:10px;
    box-shadow:0 0 0 2px rgba(0,0,0,.25), 0 0 18px rgba(0,255,220,.35);
    pointer-events:none;
    z-index:2;
    opacity:.15;
    transition: opacity .2s linear;
  }

  /* ì¹´ë©”ë¼ ì¸ì‹ ì½ê¸° ë°°ì§€(ìš°ì¸¡ íŒ¨ë„) */
  #digitReadout{
    position:absolute;
    left:50%;
    transform:translateX(-50%);
    bottom:12px;
    z-index:2;
    display:inline-flex;
    align-items:center;
    gap:.55rem;
    font: 800 13px/1 system-ui;
    color:#fff;
    padding:.48rem .8rem;
    border-radius:999px;
    border:1px solid rgba(255,255,255,.35);
    background:rgba(0,0,0,.35);
    backdrop-filter: blur(6px);
  }
  #digitReadout .value{
    font: 900 18px/1.1 ui-monospace, Menlo, Consolas, monospace;
    padding: 2px 8px;
    border-radius: 8px;
    background: rgba(255,255,255,.12);
    box-shadow: 0 0 0 2px rgba(255,255,255,.18) inset;
  }

  /* ë¦¬ì‚¬ì´ì € ë°” */
  #rightDivider{
    flex:0 0 6px;
    cursor: row-resize;
    background: repeating-linear-gradient(90deg, #d1d5db 0, #d1d5db 6px, #e5e7eb 6px, #e5e7eb 12px);
  }

  /* ë¡œê·¸ íŒ¨ë„ */
  #rightBottom{
    flex: 0 0 var(--logH);
    display:flex;
    flex-direction:column;
    min-height:0;
    overflow:hidden;
    padding: calc(10px * var(--uiScale));
    background:#0b0f14;
    color:#d1e4ff;
    border-top:1px solid #1f2937;
  }
  #log{
    flex:1 1 0;
    min-height:0;
    overflow:auto;
    white-space:pre-wrap;
    background:#0b0f14;
    border:1px solid #1f2937;
    border-radius: calc(8px * var(--uiScale));
    padding: calc(10px * var(--uiScale));
    font-family: ui-monospace, Menlo, Consolas, monospace;
    font-size: calc(12px * var(--uiScale));
    color:#d1e4ff;
  }

  /* ì‹¤í–‰ì°½ í† ê¸€ í•¸ë“¤ (ìŠ¬ë¼ì´ë”ë§Œ ì‚¬ìš© â€“ ìˆ¨ê¹€ ìƒíƒœ) */
  #panelHandle{
    position:absolute;
    top: calc(12px * var(--uiScale));
    right: 0;
    z-index:999;
    width: var(--handleW);
    height: var(--handleH);
    background: var(--blue);
    border: 0;
    border-radius: calc(6px * var(--uiScale));
    box-shadow: 0 2px 8px rgba(0,0,0,.18);
    cursor: pointer;
    padding: 0;
  }
  #panelHandle::before{
    content:'';
    position:absolute;
    top:0;
    right: calc(0px - var(--linkBar));
    width: var(--linkBar);
    height:100%;
    background: var(--blue);
    border-top-right-radius: calc(6px * var(--uiScale));
    border-bottom-right-radius: calc(6px * var(--uiScale));
  }
  #panelHandle::after{
    content:'';
    position:absolute;
    top:50%;
    transform: translateY(-50%);
    width:0;
    height:0;
    border-style: solid;
  }
  #panelHandle.open::after{
    left: calc((var(--handleW) - var(--triW)) / 2);
    border-width: var(--triH) 0 var(--triH) var(--triW);
    border-color: transparent transparent transparent white;
  }
  #panelHandle.closed::after{
    left: calc((var(--handleW) - var(--triW)) / 2);
    border-width: var(--triH) var(--triW) var(--triH) 0;
    border-color: transparent white transparent transparent;
  }
  .blocklyZoom,.blocklyTrash{ display:block !important; }
  .blocklyTrashLid, .blocklyTrashcanLid, .blocklyTrashCanLid { display:none !important; }

  body.fs-active #main{ height: calc(100vh - var(--headerH)); }
  body.panel-collapsed #right{ display:none; }
  body.panel-collapsed #left{ flex:1 1 100%; }

  /* â”€â”€ ì „ì²´í™”ë©´ ì˜¤ë²„ë ˆì´ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  #playOverlay{
    position:fixed;
    inset:0;
    background:#000;
    color:#fff;
    display:none;
    z-index:10000;
    touch-action:none;
    overscroll-behavior:contain;
    -webkit-tap-highlight-color:transparent;
    --eyesGap: 4.8vmin;
    --eyeSize: 25.2vmin;
    --pupilSize: 9.6vmin;
  }
  @media (orientation: landscape){
    #playOverlay{
      --eyesGap: calc(4.8vmin * 2);
      --eyeSize: calc(25.2vmin * 1.5);
      --pupilSize: calc(9.6vmin * 1.5);
    }
  }
  #playOverlay.show{
    display:flex;
    flex-direction:column;
  }
  /* ì—¬ê¸°ì—ì„œë„ grid ì‚¬ìš© (ìœ„ìª½ íŒ¨ì¹˜ì™€ ë™ì¼í•œ ë¹„ìœ¨) */
  #playOverlay .body{
    flex:1 1 auto;
    display:grid;
    grid-template-columns: minmax(0, 2.6fr) minmax(260px, 1fr);
    gap:0;
    background:#000;
    height:100%;
  }

  /* ëˆˆë™ì UI (í˜„ì¬ëŠ” ìˆ¨ê¹€ ìƒíƒœì§€ë§Œ êµ¬ì¡° ìœ ì§€) */
  #eyesStage{
    width:100%;
    height:100%;
    display:grid;
    place-items:center;
    background:#000;
  }
  .eyes{
    display:grid;
    grid-auto-flow:column;
    align-items:center;
    gap: var(--eyesGap);
  }
  .eye{
    position:relative;
    width:var(--eyeSize);
    height:var(--eyeSize);
    border-radius: 50%;
    overflow:hidden;
    background: radial-gradient(ellipse at 40% 40%, #fff 0 70%, #e9e9e9 100%);
    box-shadow: 0 1.2vmin 3vmin rgba(0,0,0,.45),
                inset 0 -0.8vmin 1.6vmin rgba(0,0,0,.12);
  }
  .pupil{
    position:absolute;
    width:var(--pupilSize);
    height:var(--pupilSize);
    border-radius:50%;
    background: radial-gradient(circle at 40% 35%, #222 0 45%, #000 70%, #000 100%);
    left:50%;
    top:50%;
    transform:translate(-50%,-50%);
    will-change: transform;
  }
  .shine{
    position:absolute;
    width: calc(var(--pupilSize)*.35);
    height: calc(var(--pupilSize)*.35);
    border-radius:50%;
    background: rgba(255,255,255,.85);
    left:25%;
    top:22%;
    filter: blur(0.2vmin);
  }
  .shine::after{
    content:"";
    position:absolute;
    width:55%;
    height:55%;
    left:150%;
    top:130%;
    border-radius:50%;
    background: rgba(255,255,255,.4);
    filter: blur(0.25vmin);
  }
  .eyelid{
    position:absolute;
    inset:0;
    background:#000;
    transform-origin:top center;
    transform:scaleY(0);
    pointer-events:none;
  }
  .blink .eyelid{
    animation: blink var(--blinkSpeed) ease-in-out forwards;
  }
  @keyframes blink{
    0%{transform:scaleY(0)}
    45%{transform:scaleY(1)}
    100%{transform:scaleY(0)}
  }

  /* === íŒŒì¼ ë“œë¡­ë‹¤ìš´ === */
  .dropdown{ position:relative; }
  .dropdown .menu{
    position:absolute;
    right:0;
    top:calc(100% + 4px);
    display:none;
    min-width:140px;
    background:#ffffff;
    border:1px solid #d1d5db;
    border-radius:8px;
    box-shadow:0 6px 16px rgba(0,0,0,.12);
    padding:6px;
    z-index:1000;
  }
  .dropdown .menu.show{ display:block; }
  .dropdown .menu > button{
    width:100%;
    background:transparent;
    border:0;
    cursor:pointer;
    padding:8px 10px;
    border-radius:6px;
    font-size:calc(13px * var(--uiScale));
    text-align:left;
    color:#111827;
  }
  .dropdown .menu > button:hover{ background:#f3f4f6; }
  #fileBtn{ background:#6b7280; color:#ffffff; }
</style>

<!-- ì¢Œìš° í¬ê¸° ìŠ¬ë¼ì´ë” -->
<style id="xrobo-hsplit-style">
  :root{ --rightW: 40%; } /* initial right width */
  #hResizer{
    flex: 0 0 8px;
    background: linear-gradient(90deg,#e5e7eb,#d1d5db);
    border-left: 1px solid #cbd5e1;
    border-right: 1px solid #cbd5e1;
    cursor: col-resize;
    touch-action: none;
    margin: 8px 0;
  }
  body.hs-resizing,
  body.hs-resizing *{
    cursor: col-resize !important;
    user-select: none !important;
  }
  #right{
    flex: 0 0 var(--rightW) !important;
    width: var(--rightW) !important;
    min-width: 0 !important;
  }
</style>
<style id="single-change-hide-handle">
  /* ê¸°ì¡´ ì—´ê¸°/ë‹«ê¸° ë²„íŠ¼ ìˆ¨ê¹€ (ìŠ¬ë¼ì´ë”ë¡œë§Œ ì¡°ì ˆ) */
  #panelHandle { display: none !important; }
</style>

<!-- ì•ˆë“œë¡œì´ë“œìš© ìˆ«ì í‚¤íŒ¨ë“œ ìŠ¤íƒ€ì¼ (ì›ë³¸ ìœ ì§€) -->
<style id="xrobo-kp4x4-v14-style">
  :root { --xroboKpScale: .7; }
  #xrobo-kp4x4-v14{
    position:absolute;
    left:0;
    top:0;
    display:none;
    z-index:2147483647;
    background:#000;
    border:2px solid #000;
    border-radius:calc(16px * var(--xroboKpScale));
    padding: calc(12px * var(--xroboKpScale));
    box-shadow:0 16px 46px rgba(0,0,0,.45);
    user-select:none;
    touch-action:manipulation;
  }
  #xrobo-kp4x4-v14.show{ display:block; }
  #xrobo-kp4x4-v14 .display{
    margin-bottom:calc(10px * var(--xroboKpScale));
    background:#0b0f14;
    color:#e5e7eb;
    border:1px solid #1f2937;
    border-radius:calc(10px * var(--xroboKpScale));
    padding:calc(10px * var(--xroboKpScale)) calc(12px * var(--xroboKpScale));
    font-weight:800;
    font-size:calc(18px * var(--xroboKpScale));
    letter-spacing:.6px;
    min-height:24px;
  }
  #xrobo-kp4x4-v14 .grid{
    display:grid;
    grid-template-columns: repeat(4, calc(56px * var(--xroboKpScale)));
    grid-auto-rows: calc(56px * var(--xroboKpScale));
    gap: calc(10px * var(--xroboKpScale));
  }
  #xrobo-kp4x4-v14 button{
    border:0;
    border-radius:calc(12px * var(--xroboKpScale));
    background:#fff;
    color:#111;
    font-weight:900;
    font-size:calc(20px * var(--xroboKpScale));
    box-shadow:0 calc(4px * var(--xroboKpScale)) calc(14px * var(--xroboKpScale)) rgba(0,0,0,.22);
    cursor:pointer;
  }
  #xrobo-kp4x4-v14 button:active{ transform:translateY(1px); }
  #xrobo-kp4x4-v14 .op{ background:#e6eefc; color:#0b3aa6; font-weight:800; }
  #xrobo-kp4x4-v14 .back{ background:#111827; color:#fff; font-size:calc(18px * var(--xroboKpScale)); }
  #xrobo-kp4x4-v14 .clear{ background:#e5e7eb; color:#111827; font-size:calc(16px * var(--xroboKpScale)); font-weight:800; }
  #xrobo-kp4x4-v14 .wide{ grid-column: span 2; height:calc(56px * var(--xroboKpScale)); font-size:calc(18px * var(--xroboKpScale)); font-weight:800; }
  #xrobo-kp4x4-v14 .ok{ background:#2563eb; color:#fff; }
  #xrobo-kp4x4-v14 .cancel{ background:#6b7280; color:#fff; }
</style>

<!-- â˜…â˜…â˜… ì‹¤í–‰ ì „ì²´í™”ë©´ì—ì„œ ì¹´ë©”ë¼ë§Œ ì‚¬ìš© + ì‹¤í–‰ ë¡œê·¸ ìˆ¨ê¹€ íŒ¨ì¹˜ (ì›ë³¸ ìœ ì§€) â˜…â˜…â˜… -->
<style id="overlay-fullcam-patch">
  /* ì‹¤í–‰(ì „ì²´í™”ë©´)ì—ì„œëŠ” ì¹´ë©”ë¼ í™”ë©´ë§Œ ì „ì²´ ì‚¬ìš©, ì˜¤ë¥¸ìª½ ì‹¤í–‰ ë¡œê·¸ íŒ¨ë„ ìˆ¨ê¹€ */
  #playOverlay .body{
    flex:1 1 auto;
    display:flex;
    flex-direction:column;
    height:100%;
    background:#000;
  }
  #ovRight{
    display:none !important;
  }
</style>

</head>
<body>
  <!-- í—¤ë” -->
  <header id="appHeader">
    <div id="topbar">
      <div class="title">XROBO v5 â€” ì–¼êµ´ ë°©í–¥ ì¸ì‹</div>
      <div class="spacer"></div>

      <!-- íŒŒì¼ ë“œë¡­ë‹¤ìš´ -->
      <div class="dropdown" id="fileDropdown">
        <button id="fileBtn" class="btn" title="íŒŒì¼">íŒŒì¼ â–¾</button>
        <div id="fileMenu" class="menu" role="menu" aria-hidden="true">
          <button data-cmd="new"  role="menuitem">ìƒˆë¡œë§Œë“¤ê¸°</button>
          <button data-cmd="save" role="menuitem">ì €ì¥í•˜ê¸°</button>
          <button data-cmd="load" role="menuitem">ë¶ˆëŸ¬ì˜¤ê¸°</button>
        </div>
      </div>

      <span class="state"><span id="statusDot" class="badgeDot off">off</span></span>
      <button id="connectToggle" class="btn">ì—°ê²°</button>

      <!-- í…ŒìŠ¤íŠ¸/ì‹¤í–‰ -->
      <button id="testBtn" class="btn" title="ì½”ë”© í™”ë©´ì—ì„œ í…ŒìŠ¤íŠ¸ ì‹¤í–‰">í…ŒìŠ¤íŠ¸</button>
      <button id="runToggle" class="btn" title="ì „ì²´í™”ë©´ ì¸ì‹ ì‹¤í–‰">ì‹¤í–‰</button>

      <button id="fsBtn" class="btn" title="ì „ì²´í™”ë©´">ì „ì²´í™”ë©´</button>
    </div>
  </header>

  <!-- ë³¸ë¬¸ -->
  <div id="main">
    <div id="left">
      <div id="blocklyDiv"></div>
      <button id="panelHandle" class="open" title="ì‹¤í–‰ì°½ ë‹«ê¸°"></button>
    </div>

    <div id="hResizer" class="hsplit" title="ì¢Œìš° í¬ê¸° ì¡°ì ˆ ë°”"></div>

    <div id="right">
      <!-- ìš°ì¸¡ ìƒë‹¨: ì¹´ë©”ë¼ í”„ë¦¬ë·° -->
      <div id="rightTop">
        <div class="camWrap" id="camWrap">
          <video id="camVideo" playsinline autoplay muted></video>
          <div id="focusBox"></div>

          <!-- â˜… ì–¼êµ´ ê±°ë¦¬ ì•ˆë‚´(ìƒë‹¨) -->
          <div id="faceDistHint" class="camDistHint">â€”</div>

          <div class="camUi">
            <span id="camBadge" class="camBadge">Cam: off</span>
            <button id="camToggle" class="btn small">ìº  ì¼œê¸°</button>
          </div>
          <!-- ì¸ì‹ í‘œì‹œ(íŒ¨ë„) -->
          <div id="digitReadout">
            <span class="label">ì–¼êµ´ë°©í–¥</span>
            <span class="value">â€”</span>
          </div>
        </div>
      </div>

      <div id="rightDivider" title="ë“œë˜ê·¸í•˜ì—¬ ë¡œê·¸ ë†’ì´ ì¡°ì ˆ"></div>

      <div id="rightBottom">
        <div style="font-size:calc(12px * var(--uiScale));color:#9ca3af;">ì‹¤í–‰ ë¡œê·¸</div>
        <div id="log"></div>
      </div>
    </div>
  </div>

  <!-- íˆ´ë°•ìŠ¤ -->
  <xml id="toolbox" style="display:none">
    <category name="ì´ë²¤íŠ¸" colour="#f59e0b">
      <block type="xrobo_start"></block>
    </category>
    <category name="ì¶œë ¥" colour="#60a5fa">
      <block type="motor12_dd">
        <field name="M1">20</field>
        <field name="M2">20</field>
        <field name="MS">500</field>
      </block>
      <block type="motor12_in">
        <value name="M1"><shadow type="math_number"><field name="NUM">20</field></shadow></value>
        <value name="M2"><shadow type="math_number"><field name="NUM">20</field></shadow></value>
        <value name="MS"><shadow type="math_number"><field name="NUM">500</field></shadow></value>
      </block>
      <block type="melody">
        <field name="PITCH">C4</field>
        <value name="DUR"><shadow type="math_number"><field name="NUM">200</field></shadow></value>
        <value name="WAIT"><shadow type="math_number"><field name="NUM">0</field></shadow></value>
      </block>
      <block type="led_ctrl">
        <field name="TGT">OUT1</field>
        <field name="MODE">BRIGHT</field>
        <field name="VAL">10</field>
      </block>
    </category>
    <category name="ì œì–´" colour="#10b981">
      <block type="controls_repeat_ext">
        <value name="TIMES"><shadow type="math_number"><field name="NUM">3</field></shadow></value>
      </block>
      <block type="wait_seconds">
        <value name="SEC"><shadow type="math_number"><field name="NUM">1</field></shadow></value>
      </block>
    </category>
  </xml>

  <!-- ì „ì²´í™”ë©´ ì˜¤ë²„ë ˆì´ -->
  <div id="playOverlay" aria-hidden="true">
    <div class="body">
      <div id="ovCamWrap">
        <video id="eyesCam" playsinline muted autoplay></video>
        <div id="ovFocusBox"></div>

        <!-- â˜… ì–¼êµ´ ê±°ë¦¬ ì•ˆë‚´(ìƒë‹¨) -->
        <div id="ovFaceDistHint" class="camDistHint">â€”</div>

        <div id="overlayDigitBadge">
          <span class="label">ì–¼êµ´ë°©í–¥</span>
          <span class="value">â€”</span>
        </div>
      </div>

      <div id="ovRight" class="ov-right-panel" aria-label="ì‹¤í–‰ ë¡œê·¸ ì˜ì—­">
        <div class="ov-header">ì‹¤í–‰ ë¡œê·¸</div>
        <div id="ovLog" class="ov-log" role="log" aria-live="polite" aria-atomic="false"></div>
      </div>

      <div id="eyesStage" aria-label="ê·€ì—¬ìš´ ëˆˆë™ì">
        <div class="eyes">
          <div class="eye">
            <div class="pupil"><div class="shine"></div></div>
            <div class="eyelid"></div>
          </div>
          <div class="eye">
            <div class="pupil"><div class="shine"></div></div>
            <div class="eyelid"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
/* ================= Blockly ê¸°ë³¸ ì„¤ì • ================= */
class XroboZelosProvider extends Blockly.zelos.ConstantProvider {
  constructor(){
    super();
    this.ADD_START_HATS = true;
  }
}
class XroboZelosRenderer extends Blockly.zelos.Renderer {
  constructor(){ super('xrobo_zelos'); }
  makeConstants_(){ return new XroboZelosProvider(); }
}
Blockly.blockRendering.register('xrobo_zelos', XroboZelosRenderer);
const XroboTheme = Blockly.Theme.defineTheme('xrobo_theme', {
  base: Blockly.Themes.Zelos,
  componentStyles: { startHats: true }
});

var ws = Blockly.inject('blocklyDiv', {
  toolbox: document.getElementById('toolbox'),
  renderer: 'xrobo_zelos',
  theme: XroboTheme,
  grid: { spacing:20, length:3, colour:'#eee', snap:true },
  zoom: { controls:true, wheel:true, startScale:1, minScale:0.5, maxScale:2 },
  move: { scrollbars:true, drag:true, wheel:true },
  trashcan: true
});

/* â–¼â–¼ Blockly v12 ë³€ìˆ˜ API ê²½ê³  ì œê±°ìš© SHIM â–¼â–¼ */
(function patchBlocklyDeprecated(){
  try{
    if (Blockly.Workspace && Blockly.Workspace.prototype && Blockly.Workspace.prototype.getAllVariables) {
      Blockly.Workspace.prototype.getAllVariables = function(){
        var vm = this.getVariableMap ? this.getVariableMap() : null;
        return (vm && vm.getAllVariables) ? vm.getAllVariables() : [];
      };
    }
  }catch(e){}
})();
/* â–²â–² SHIM ë â–²â–² */

/* ë“œë˜ê·¸ ì¤‘ ìë™ ìŠ¤í¬ë¡¤ ë°©ì§€ */
(function disableAutoScrollWhileBlockDragging(){
  try{
    if (Blockly.BlockDragger && Blockly.BlockDragger.prototype) {
      var orig = Blockly.BlockDragger.prototype.updateDrag;
      if (typeof orig === 'function') {
        Blockly.BlockDragger.prototype.updateDrag = function(e){
          var saved = this.autoScroll_;
          this.autoScroll_ = null;
          var r = orig.call(this, e);
          this.autoScroll_ = saved;
          return r;
        };
      }
    }
  }catch(e){ console.warn('AutoScroll patch failed', e); }
})();

/* ================= ìƒìˆ˜/ê³µìš© ================= */
var PINS_OUT=[["OUT1","OUT1"],["OUT2","OUT2"],["OUT3","OUT3"],["OUT4","OUT4"],["OUT5","OUT5"],["OUT6","OUT6"],["OUT7","OUT7"],["OUT8","OUT8"]];
var SPEEDS=Array.from({length:41},(_,i)=>20-i).map(v=>[String(v),String(v)]);
var TIMES100=Array.from({length:10},(_,i)=>100*(i+1)).map(v=>[String(v),String(v)]);
var LED_TGT=[].concat(PINS_OUT,[["CPU","CPU"]]);
var LED_MODE=[["ë°ê¸°","BRIGHT"],["ìˆ¨ì‰¬ê¸°","BREATHE"]];
var LED_VALS=Array.from({length:20},(_,i)=>[String(i),String(i)]);

/* ================= ë¸”ë¡ ì •ì˜ ================= */
/* â˜… ì´ë²¤íŠ¸ ë¸”ë¡(ì–¼êµ´ ë°©í–¥) ì˜µì…˜ â˜… */
const DIGIT_OPTIONS = [
  ["ì •ë©´","F_FRONT"],
  ["ìœ„","F_UP"],
  ["ì•„ë˜","F_DOWN"],
  ["ì™¼ìª½","F_LEFT"],
  ["ì˜¤ë¥¸ìª½","F_RIGHT"]
];
Blockly.defineBlocksWithJsonArray([
  {
    "type":"xrobo_start",
    "message0":"ì–¼êµ´ ë°©í–¥ %1 ì´ ë³´ì´ë©´",
    "args0":[{ "type":"field_dropdown","name":"DIGIT","options": DIGIT_OPTIONS }],
    "nextStatement":null,
    "colour":36,
    "hat":"cap"
  },
  {
    "type":"motor12_dd",
    "message0":"ëª¨í„° M1 %1  M2 %2  ì‹œê°„ %3 ms",
    "args0":[
      {"type":"field_dropdown","name":"M1","options":SPEEDS},
      {"type":"field_dropdown","name":"M2","options":SPEEDS},
      {"type":"field_dropdown","name":"MS","options":TIMES100}
    ],
    "previousStatement":null,
    "nextStatement":null,
    "inputsInline":true,
    "colour":210
  },
  {
    "type":"motor12_in",
    "message0":"ëª¨í„° M1 %1  M2 %2  ì‹œê°„ %3 ms",
    "args0":[
      {"type":"input_value","name":"M1","check":"Number"},
      {"type":"input_value","name":"M2","check":"Number"},
      {"type":"input_value","name":"MS","check":"Number"}
    ],
    "previousStatement":null,
    "nextStatement":null,
    "inputsInline":true,
    "colour":210
  },
  {
    "type":"melody",
    "message0":"ë©œë¡œë”” ìŒë†’ì´ %1 ì†Œë¦¬ì‹œê°„ %2 ms ëŒ€ê¸°ì‹œê°„ %3 ms",
    "args0":[
      {"type":"field_dropdown","name":"PITCH","options":(function(){
        var KR=["ë„","ë ˆ","ë¯¸","íŒŒ","ì†”","ë¼","ì‹œ"], EN=["C","D","E","F","G","A","B"], L=[];
        for(var o=4;o<=6;o++) for(var i=0;i<7;i++) L.push([KR[i]+o, EN[i]+o]);
        return L;
      })()},
      {"type":"input_value","name":"DUR","check":"Number"},
      {"type":"input_value","name":"WAIT","check":"Number"}
    ],
    "previousStatement":null,
    "nextStatement":null,
    "inputsInline":true,
    "colour":300
  },
  {
    "type":"led_ctrl",
    "message0":"LED %1 ëª¨ë“œ %2 ê°’ %3",
    "args0":[
      {"type":"field_dropdown","name":"TGT","options":LED_TGT},
      {"type":"field_dropdown","name":"MODE","options":LED_MODE},
      {"type":"field_dropdown","name":"VAL","options":LED_VALS}
    ],
    "previousStatement":null,
    "nextStatement":null,
    "inputsInline":true,
    "colour":330
  },
  {
    "type":"wait_seconds",
    "message0":"%1 ì´ˆ ê¸°ë‹¤ë¦¬ê¸°",
    "args0":[{"type":"input_value","name":"SEC","check":"Number"}],
    "previousStatement":null,
    "nextStatement":null,
    "inputsInline":true,
    "colour":120
  }
]);

/* ================= ì½”ë“œ ë¹Œë” ================= */
function numFromInput(parent, name, def){
  if (def===void 0) def=0;
  var raw = Blockly.JavaScript.valueToCode(parent, name, Blockly.JavaScript.ORDER_NONE);
  var n = Number(raw != null ? raw : '');
  return (isFinite(n) ? n : def);
}
function walkNode(b, list){
  if(!b) return;
  switch(b.type){
    case 'motor12_dd':{
      var v1=+b.getFieldValue('M1'),
          v2=+b.getFieldValue('M2'),
          ms=+b.getFieldValue('MS');
      list.push({type:'CMD',s:'M12 '+v1+' '+v2+' '+ms});
      if(ms>0) list.push({type:'W',args:[ms]});
      break;
    }
    case 'motor12_in':{
      var v1n=numFromInput(b,'M1',0),
          v2n=numFromInput(b,'M2',0),
          msn=numFromInput(b,'MS',0);
      list.push({type:'CMD',s:'M12 '+Math.round(v1n)+' '+Math.round(v2n)+' '+Math.round(msn)});
      if(msn>0) list.push({type:'W',args:[msn]});
      break;
    }
    case 'melody':{
      var p=b.getFieldValue('PITCH'),
          dur=numFromInput(b,'DUR',200),
          wait=numFromInput(b,'WAIT',0);
      list.push({type:'CMD',s:'MEL '+p+' '+Math.round(dur)+' '+Math.round(wait)});
      if(wait>0) list.push({type:'W',args:[wait]});
      break;
    }
    case 'led_ctrl':{
      var t=b.getFieldValue('TGT'),
          m=b.getFieldValue('MODE'),
          v=+b.getFieldValue('VAL');
      list.push({type:'CMD',s:'LED '+t+' '+m+' '+v});
      break;
    }
    case 'controls_repeat_ext':{
      var times=Math.max(0, numFromInput(b,'TIMES',1));
      var inner=[];
      var first=b.getInputTargetBlock('DO');
      walkChain(first, inner);
      list.push({type:'FOR',count:times,body:inner});
      break;
    }
    case 'wait_seconds':{
      var s=numFromInput(b,'SEC',1);
      if(s>0) list.push({type:'W',args:[s*1000]});
      break;
    }
  }
}
function walkChain(start, list){
  for(var n=start; n; n=n.getNextBlock()){
    walkNode(n, list);
  }
}
function normalizeProgram(list){
  var out=[];
  for(var i=0;i<list.length;i++){
    var ins=list[i];
    if(ins.type==='CMD'){
      var prev=out[out.length-1];
      if(prev && prev.type==='CMD' && prev.s===ins.s) continue;
    }else if(ins.type==='W'){
      if(!isFinite(ins.args && ins.args[0]) || ins.args[0]<=0) continue;
      var prevw=out[out.length-1];
      if(prevw && prevw.type==='W'){
        prevw.args[0]+=ins.args[0];
        continue;
      }
    }
    out.push(ins);
  }
  return out;
}
function buildEventPrograms(){
  const programs = { F_FRONT:[], F_UP:[], F_DOWN:[], F_LEFT:[], F_RIGHT:[] };
  var evs = ws.getBlocksByType('xrobo_start', true);
  for(var i=0;i<evs.length;i++){
    var code = evs[i].getFieldValue('DIGIT') || 'F_FRONT';
    var chain = evs[i].getNextBlock();
    if(!chain) continue;
    var prog=[];
    walkChain(chain, prog);
    var norm = normalizeProgram(prog);
    if(!programs[code]) programs[code] = [];
    programs[code] = programs[code].concat(norm);
  }
  return programs;
}

/* ================= í—¤ë”/ìŠ¤ì¼€ì¼/í’€ìŠ¤í¬ë¦° ================= */
function applyHeaderHeight(){
  var px = document.getElementById('appHeader').offsetHeight || 64;
  document.documentElement.style.setProperty('--headerH', px+'px');
  setTimeout(function(){ Blockly.svgResize(ws); }, 60);
}
function applyUiScaleFromWorkspace(){
  var s = Math.max(.7, Math.min(1.6, ws.getScale()));
  document.documentElement.style.setProperty('--uiScale', s);
  applyHeaderHeight();
}
window.addEventListener('resize', applyHeaderHeight);
document.addEventListener('fullscreenchange', applyHeaderHeight);
ws.addChangeListener(function(ev){
  if(ev && ev.type===Blockly.Events.UI && ev.element==='zoom'){
    applyUiScaleFromWorkspace();
  }
});
setInterval(function(){ applyUiScaleFromWorkspace(); }, 200);
applyUiScaleFromWorkspace();
applyHeaderHeight();

/* ================= BLE & ë¡œê·¸ ================= */
var SERVICE_UUID=0xFFF0;
var bleDevice=null,bleServer=null,bleService=null,writeChar=null,notifyChar=null;
var isConnected=false, isRunning=false, isFullscreenRun=false;
var $=id=>document.getElementById(id);

/* ë¡œê·¸: ìš°ì¸¡ íŒ¨ë„ + ì „ì²´í™”ë©´ ë¡œê·¸ ë‘˜ ë‹¤ì— ì¶œë ¥ */
var log=function(m){
  var L=$('log');
  if(L){
    L.textContent+=m+"\n";
    L.scrollTop=L.scrollHeight;
  }
  var OL=$('ovLog');
  if(OL){
    OL.textContent+=m+"\n";
    OL.scrollTop=OL.scrollHeight;
  }
};

var dot=$('statusDot');
var btnConnect=$('connectToggle'),
    btnRun    =$('runToggle'),
    btnTest   =$('testBtn');

var enc = s=> new TextEncoder().encode(s);

function resetBleRefs(){
  bleDevice=null;
  bleServer=null;
  bleService=null;
  writeChar=null;
  notifyChar=null;
}
function setConnected(v){
  isConnected=v;
  btnConnect.textContent=v?'í•´ì œ':'ì—°ê²°';
  dot.classList.toggle('on',v);
  dot.classList.toggle('off',!v);
  dot.textContent=v?'on':'off';
  if(!v) setRunning(false);
}
function setRunning(v){
  isRunning=v;
  btnRun.textContent = v ? 'â–  ì •ì§€' : 'ì‹¤í–‰';
  btnRun.style.background = v ? '#ef4444' : '#16a34a';
  btnTest.disabled = v;
}

/* BLE connect/disconnect */
function connectBLE(){
  if(!navigator.bluetooth){
    alert('ì´ ë¸Œë¼ìš°ì €ëŠ” Web Bluetooth ë¯¸ì§€ì›ì…ë‹ˆë‹¤.');
    return;
  }
  (async function(){
    try{
      var dev = await navigator.bluetooth.requestDevice({
        filters:[{ namePrefix:'XROBO' }],
        optionalServices:[SERVICE_UUID, 0xFFF3, 0xFFF4]
      });
      try{
        if (bleDevice && bleDevice.removeEventListener){
          bleDevice.removeEventListener('gattserverdisconnected', onDisconnected);
        }
      }catch(e){}
      resetBleRefs();
      bleDevice=dev;
      if (bleDevice && bleDevice.addEventListener){
        bleDevice.addEventListener('gattserverdisconnected', onDisconnected);
      }

      bleServer=await bleDevice.gatt.connect();
      bleService=await bleServer.getPrimaryService(SERVICE_UUID);

      try{ writeChar=await bleService.getCharacteristic(0xFFF3);}catch(e){}
      try{ notifyChar=await bleService.getCharacteristic(0xFFF4);}catch(e){}
      if(!writeChar || notifyChar==null){
        var cs=await bleService.getCharacteristics();
        for(var i=0;i<cs.length;i++){
          var ch=cs[i], p=ch.properties||{};
          if(!writeChar && (p.write||p.writeWithoutResponse)) writeChar=ch;
          if(!notifyChar && p.notify) notifyChar=ch;
        }
      }
      if(!writeChar) throw new Error('write íŠ¹ì„±ì„ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.');
      if(notifyChar){
        await notifyChar.startNotifications();
        if (notifyChar.addEventListener){
          notifyChar.addEventListener('characteristicvaluechanged',function(ev){
            try{
              var v=new TextDecoder().decode(ev.target.value||new Uint8Array());
              log('â¬…ï¸ '+v.trim());
            }catch(e){}
          });
        }
      }
      setConnected(true);
      log('âœ… ì—°ê²°: '+(dev.name||'(ì´ë¦„ ì—†ìŒ)'));
    }catch(e){
      console.error(e);
      log('âŒ ì—°ê²° ì‹¤íŒ¨: '+e);
      setConnected(false);
      resetBleRefs();
    }
  })();
}
function onDisconnected(){
  log('ğŸ”Œ í•´ì œë¨');
  setConnected(false);
  resetBleRefs();
}
function disconnectBLE(){
  try{
    if (bleDevice && bleDevice.gatt) bleDevice.gatt.disconnect();
  }catch(e){}
  setConnected(false);
  resetBleRefs();
}
btnConnect.onclick = ()=> isConnected ? disconnectBLE() : connectBLE();

/* ================= ì €ì¥/ë¶ˆëŸ¬ì˜¤ê¸° ================= */
function serializeProject(){
  var xmlDom = Blockly.Xml.workspaceToDom(ws);
  var xmlText = Blockly.Xml.domToText(xmlDom);
  return JSON.stringify({type:'xrobo_project_v1', xml: xmlText}, null, 2);
}
function saveProject(){
  var data = serializeProject();
  var suggestedName = 'xrobo_project.json';
  if(window.showSaveFilePicker){
    (async function(){
      try{
        var handle = await showSaveFilePicker({
          suggestedName,
          types:[{description:'XROBO Project', accept:{'application/json':['.json']}}]
        });
        var stream = await handle.createWritable();
        await stream.write(new Blob([data], {type:'application/json'}));
        await stream.close();
        log('ğŸ’¾ ì €ì¥ ì™„ë£Œ');
      }catch(e){
        if(!(e && e.name==='AbortError')) log('âš ï¸ ì €ì¥ ì‹¤íŒ¨: '+e);
      }
    })();
  }else{
    var a=document.createElement('a');
    a.href=URL.createObjectURL(new Blob([data], {type:'application/json'}));
    a.download=suggestedName;
    a.click();
    setTimeout(()=>{ URL.revokeObjectURL(a.href); }, 1000);
    log('ğŸ’¾ ì €ì¥(ë‹¤ìš´ë¡œë“œ) ì™„ë£Œ');
  }
}
function loadProject(){
  (async function(){
    try{
      var text='';
      if(window.showOpenFilePicker){
        var arr = await showOpenFilePicker({
          types:[{description:'XROBO Project', accept:{'application/json':['.json']}}]
        });
        var handle = arr[0];
        var file = await handle.getFile();
        text = await file.text();
      }else{
        var input=document.createElement('input');
        input.type='file';
        input.accept='.json,application/json';
        var pick = new Promise((res,rej)=>{
          input.onchange=()=>{ res(input.files[0]||null); };
          input.onerror=rej;
        });
        input.click();
        var file = await pick;
        if(!file) return;
        text = await file.text();
      }
      var obj = JSON.parse(text);
      if(!obj || obj.type!=='xrobo_project_v1') throw new Error('ì•Œ ìˆ˜ ì—†ëŠ” í”„ë¡œì íŠ¸ í˜•ì‹');
      ws.clear();
      var parser = new DOMParser();
      var xml = parser.parseFromString(obj.xml, 'text/xml');
      Blockly.Xml.domToWorkspace(xml.documentElement, ws);
      log('ğŸ“‚ ë¶ˆëŸ¬ì˜¤ê¸° ì™„ë£Œ');
    }catch(e){
      if(!(e && e.name==='AbortError')) alert('ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨: '+e);
    }
  })();
}

/* ================= ì˜¤ë¥¸ìª½ íŒ¨ë„: ë¡œê·¸ ë†’ì´ ë¦¬ì‚¬ì´ì € ================= */
(function(){
  var divider = document.getElementById('rightDivider');
  var root = document.documentElement;
  var dragging=false, startY=0, startH=0, rightH=0;
  function pxToNum(px){ return Number(String(px).replace('px',''))||0; }
  function onDown(e){
    e.preventDefault();
    dragging=true;
    startY=('touches' in e ? e.touches[0].clientY : e.clientY);
    startH=pxToNum(getComputedStyle(root).getPropertyValue('--logH'));
    rightH=document.getElementById('right').clientHeight;
    window.addEventListener('mousemove', onMove);
    window.addEventListener('touchmove', onMove, {passive:false});
    window.addEventListener('mouseup', onUp, {once:true});
    window.addEventListener('touchend', onUp, {once:true});
  }
  function onMove(e){
    if(!dragging) return;
    var y=('touches' in e ? e.touches[0].clientY : e.clientY);
    if('touches' in e) e.preventDefault();
    var delta = startY - y;
    var nh = startH + delta;
    var minH=90, maxH=Math.max(130, Math.floor(rightH*0.8));
    nh=Math.min(maxH, Math.max(minH, nh));
    root.style.setProperty('--logH', nh+'px');
  }
  function onUp(){
    dragging=false;
    window.removeEventListener('mousemove', onMove);
    window.removeEventListener('touchmove', onMove);
  }
  divider.addEventListener('mousedown', onDown);
  divider.addEventListener('touchstart', onDown, {passive:false});
})();

/* ================= íŒ¨ë„ í† ê¸€ & ì „ì²´í™”ë©´ ë²„íŠ¼ ================= */
var panelHandle=document.getElementById('panelHandle');
function syncHandle(){
  var collapsed = document.body.classList.contains('panel-collapsed');
  panelHandle.classList.toggle('open',   !collapsed);
  panelHandle.classList.toggle('closed',  collapsed);
  panelHandle.title = collapsed ? 'ì‹¤í–‰ì°½ ì—´ê¸°' : 'ì‹¤í–‰ì°½ ë‹«ê¸°';
}
function togglePanel(){
  document.body.classList.toggle('panel-collapsed');
  syncHandle();
  setTimeout(()=>{ Blockly.svgResize(ws); },60);
}
panelHandle.addEventListener('click', togglePanel);
syncHandle();

var fsBtn=document.getElementById('fsBtn');
async function enterFS(){
  var el=document.documentElement;
  if(el.requestFullscreen) await el.requestFullscreen();
}
async function exitFS(){
  if(document.fullscreenElement && document.exitFullscreen) await document.exitFullscreen();
}
function syncFSLabel(){
  var a = !!document.fullscreenElement;
  document.body.classList.toggle('fs-active', a);
  fsBtn.textContent = a ? 'í™”ë©´ì¶•ì†Œ' : 'ì „ì²´í™”ë©´';
  fsBtn.title = a ? 'í™”ë©´ ì¶•ì†Œë¡œ ì „í™˜' : 'ì „ì²´í™”ë©´ìœ¼ë¡œ ì „í™˜';
  applyHeaderHeight();
}
fsBtn.onclick=async function(){
  if(document.fullscreenElement) await exitFS();
  else await enterFS();
};
document.addEventListener('fullscreenchange', syncFSLabel);
syncFSLabel();

/* ================= ì‹¤í–‰/í…ŒìŠ¤íŠ¸ & ì˜¤ë²„ë ˆì´ ì œì–´ ================= */
var overlay=document.getElementById('playOverlay');
var eventPrograms = {};
var queue = [];
var queueBusy = false;
var cancelToken = 0;

function sendRaw(s){
  if(!writeChar){
    log('â¡ï¸(BLE ë¯¸ì—°ê²°) '+s);
    return Promise.resolve();
  }
  return writeChar.writeValue(enc(s+'\n'))
    .then(()=>{ log('â¡ï¸ '+s); })
    .catch(e=>{ log('âš ï¸ ì „ì†¡ ì‹¤íŒ¨: '+e); });
}
async function runList(list, localToken){
  for(var i=0;i<list.length;i++){
    var ins=list[i];
    if(localToken !== cancelToken) return;
    if(ins.type==='CMD'){
      await sendRaw(ins.s);
    }else if(ins.type==='W'){
      var ms = (ins.args && ins.args[0]) ? ins.args[0] : 0;
      await new Promise(r=>setTimeout(r, ms));
    }else if(ins.type==='FOR'){
      for(var k=0;k<ins.count;k++){
        if(localToken !== cancelToken) return;
        await runList(ins.body, localToken);
      }
    }
  }
}
async function processQueue(localToken){
  if(queueBusy) return;
  queueBusy = true;
  try{
    while(queue.length && localToken === cancelToken){
      var item = queue.shift();
      await runList(item.list, localToken);
    }
  }finally{
    queueBusy = false;
    /* â˜… ì´ë²¤íŠ¸ ì‹¤í–‰ì´ ëë‚˜ë©´ ì¦‰ì‹œ ë‹¤ì‹œ ì¸ì‹ ì‹œì‘(0.5ì´ˆ ê¸°ë‹¤ë¦¬ì§€ ì•Šë„ë¡ íƒ€ì„ìŠ¤íƒ¬í”„ ì´ˆê¸°í™”) â˜… */
    try{ panelLastDetectTs = 0; }catch(_){}
    try{ overlayLastDetectTs = 0; }catch(_){}
  }
}

/* ì–¼êµ´ ì´ë²¤íŠ¸ ì½”ë“œ â†’ í•œê¸€ ë¼ë²¨ */
function eventLabelFromCode(code){
  switch(code){
    case 'F_FRONT': return 'ì •ë©´';
    case 'F_UP':    return 'ìœ„';
    case 'F_DOWN':  return 'ì•„ë˜';
    case 'F_LEFT':  return 'ì™¼ìª½';
    case 'F_RIGHT': return 'ì˜¤ë¥¸ìª½';
    default:        return String(code||'');
  }
}

/* ì´ë²¤íŠ¸ ì‹¤í–‰ + ë¡œê·¸ */
function triggerEvent(name, conf, source){
  var label = eventLabelFromCode(name);

  if(!isRunning){
    log(`â¸ ì‹¤í–‰ ì¤‘ì´ ì•„ë‹ˆë¼ ì´ë²¤íŠ¸ë¥¼ ì‹¤í–‰í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. (${label})`);
    return;
  }

  if(!eventPrograms || !eventPrograms[name]){
    try{ eventPrograms = buildEventPrograms(); }catch(e){}
  }
  var seq = eventPrograms[name];
  if(!seq || !seq.length){
    log(`âš ï¸ ì´ë²¤íŠ¸ ${label} ì— ì—°ê²°ëœ ë¸”ë¡ì´ ì—†ìŠµë‹ˆë‹¤.`);
    return;
  }

  if(typeof conf === 'number'){
    log(`â‘¢ ì´ë²¤íŠ¸ ${label} ì‹¤í–‰ (${seq.length}ê°œ ëª…ë ¹, ${conf.toFixed(1)}%)`);
  }else{
    log(`â‘¢ ì´ë²¤íŠ¸ ${label} ì‹¤í–‰ (${seq.length}ê°œ ëª…ë ¹)`);
  }

  queue.push({list: seq.slice()});
  var myToken = cancelToken;
  processQueue(myToken);
}

/* í…ŒìŠ¤íŠ¸ ì‹¤í–‰(ì½”ë”© í™”ë©´) */
function startTest(){
  if(isRunning) return;
  eventPrograms = buildEventPrograms();
  cancelToken++;
  queue = [];
  isFullscreenRun = false;
  setRunning(true);
}

/* ì „ì²´í™”ë©´ ì¸ì‹ ì‹¤í–‰ */
let overlayStartedCam = false;
async function startFullRun(){
  if(isRunning) return;
  eventPrograms = buildEventPrograms();
  cancelToken++;
  queue = [];
  isFullscreenRun = true;
  setRunning(true);

  overlay.classList.add('show');
  overlay.setAttribute('aria-hidden','false');
  try{
    if(overlay.requestFullscreen) await overlay.requestFullscreen();
  }catch(e){}

  overlayStartedCam = !camOn;
  if(!camOn){
    try{ await startCam(); }catch(e){ log('âš ï¸ ì‹¤í–‰ ì¤‘ ì¹´ë©”ë¼ ì‹œì‘ ì‹¤íŒ¨: '+e); }
  }
  try{
    const eyesCam = document.getElementById('eyesCam');
    if(camStream){
      eyesCam.srcObject = camStream;
      await eyesCam.play();
    }
  }catch(e){}
  startOverlayEyes();
}

/* ì •ì§€ */
async function stopRun(){
  cancelToken++;
  queue=[];
  setRunning(false);
  stopOverlayEyes();
  overlay.classList.remove('show');
  overlay.setAttribute('aria-hidden','true');
  isFullscreenRun = false;
  try{
    if(document.fullscreenElement) await document.exitFullscreen();
  }catch(e){}
  try{
    if(writeChar) writeChar.writeValue(enc('S\n'));
  }catch(e){}
  if(overlayStartedCam){
    stopCam();
    overlayStartedCam=false;
  }
}

/* ë²„íŠ¼ ë°”ì¸ë”© */
btnTest.onclick = ()=> { if(!isRunning) startTest(); };
btnRun.onclick  = ()=> { if(!isRunning) startFullRun(); else stopRun(); };

/* ì „ì²´í™”ë©´ í•´ì œ ì‹œ ìë™ ì •ì§€ */
document.addEventListener('fullscreenchange', ()=>{
  if (isFullscreenRun && !document.fullscreenElement){
    stopRun();
  }
});
document.addEventListener('keydown', (e)=>{
  if (isFullscreenRun && e.key === 'Escape') stopRun();
});

/* ================= ì¹´ë©”ë¼(íŒ¨ë„) ================= */
const camWrap   = document.getElementById('camWrap');
const camVideo  = document.getElementById('camVideo');
const camToggle = document.getElementById('camToggle');
const camBadge  = document.getElementById('camBadge');
const focusBox  = document.getElementById('focusBox');
const digitReadout = document.getElementById('digitReadout');
const digitValEl = digitReadout.querySelector('.value');
const faceDistHintEl = document.getElementById('faceDistHint');

/* ê³µìš© íŒŒë¼ë¯¸í„° */
const LOW_W = 64, LOW_H = 48;

/* ìº”ë²„ìŠ¤ íŒŒë¼ë¯¸í„° */
const OCR_W = 240, OCR_H = 240;
/* â˜… 0.5ì´ˆ ê°„ê²©(ìš”ì²­) â˜… */
const DETECT_PERIOD_MS = 500;
/* ì´ë²¤íŠ¸ ì‹¤í–‰ ìµœì†Œ ì‹ ë¢°ë„(%) */
const EVENT_CONF_MIN = 50;
/* (ì›ë³¸ ìƒìˆ˜ ìœ ì§€) */
const BG_MIN_MEAN = 90;
const GRAY_MIN_RATIO = 0.75;
const COLOR_TOLERANCE = 24;

/* â˜… ì–¼êµ´ ê±°ë¦¬ íŒì •(í”½ì…€ ê¸°ì¤€: í•„ìš”ì‹œ ì¡°ì ˆ) â˜… */
const FACE_FAR_EYE_DIST  = 55;   // ì´ ê°’ë³´ë‹¤ ì‘ìœ¼ë©´ ë©€ë¦¬ ìˆìŒ
const FACE_NEAR_EYE_DIST = 120;  // ì´ ê°’ë³´ë‹¤ í¬ë©´ ê°€ê¹Œì´ ìˆìŒ

/* â˜… ì–¼êµ´ ë°©í–¥ íŒì •(í•„ìš”ì‹œ ì¡°ì ˆ) â˜… */
const YAW_TH = 0.26;        // ì¢Œ/ìš° ë¯¼ê°ë„(0~1)
const PITCH_Z_TH = 0.03;    // ìœ„/ì•„ë˜ ë¯¼ê°ë„(z ì°¨ì´)
const PITCH_Z_SCALE = 0.09; // z ì •ê·œí™” ìŠ¤ì¼€ì¼

let camStream = null, camOn = false, camRAF = null;

const procCvs = document.createElement('canvas');
const procCtx = procCvs.getContext('2d', { willReadFrequently:true });
procCvs.width = LOW_W;
procCvs.height = LOW_H;

const ocrCvs = document.createElement('canvas');
const ocrCtx = ocrCvs.getContext('2d', { willReadFrequently:true });
ocrCvs.width = OCR_W;
ocrCvs.height = OCR_H;

/* ê°„ë‹¨ íšŒìƒ‰ ë³€í™˜(ì›ë³¸ ìœ ì§€) */
function toGray(r,g,b){ return (r*0.299 + g*0.587 + b*0.114)|0; }

/* UI */
function setCamBadge(t){ camBadge.textContent = 'Cam: ' + t; }
function updateCamUi(){
  setCamBadge(camOn ? 'on' : 'off');
  camToggle.textContent = camOn ? 'ìº  ë„ê¸°' : 'ìº  ì¼œê¸°';
}
function updateDigitReadout(v){
  digitValEl.textContent = (v==null ? 'â€”' : String(v));
}
function updateFaceDistHint(v){
  if(faceDistHintEl) faceDistHintEl.textContent = (v==null ? 'â€”' : String(v));
}

/* ì¹´ë©”ë¼ on/off */
async function startCam(){
  if(camOn) return;
  try{
    const stream = await navigator.mediaDevices.getUserMedia({
      video: {
        facingMode:{ideal:'user'},
        width:{ideal:320},
        height:{ideal:240},
        frameRate:{ideal:30,max:30}
      },
      audio: false
    });
    camStream = stream;
    camVideo.srcObject = stream;
    await camVideo.play();
    camOn = true;
    updateCamUi();
    updateDigitReadout(null);
    updateFaceDistHint('â€”');
    await ensureOcr(); /* í•¨ìˆ˜ëª… ìœ ì§€ */
    startDetectLoop();
    log('ğŸ¥ ì¹´ë©”ë¼ ì¼œì§');
  }catch(e){
    log('âŒ ì¹´ë©”ë¼ ì‹¤íŒ¨: '+e);
  }
}
function stopCam(){
  if(!camOn) return;
  try{ camVideo.pause(); }catch(_){}
  if(camVideo.srcObject){
    try{ camVideo.srcObject.getTracks().forEach(t=>t.stop()); }catch(_){}
    camVideo.srcObject = null;
  }
  camStream = null;
  camOn=false;
  updateCamUi();
  if(camRAF){ cancelAnimationFrame(camRAF); camRAF=null; }
  updateDigitReadout(null);
  updateFaceDistHint('â€”');
  if(focusBox){
    focusBox.style.left='50%';
    focusBox.style.top='50%';
    focusBox.style.opacity='.15';
  }
  log('ğŸ›‘ ì¹´ë©”ë¼ êº¼ì§');
}
camToggle.onclick = ()=> camOn ? stopCam() : startCam();

/* ===== ì–¼êµ´ ë°©í–¥ ì¸ì‹ ì¤€ë¹„(í•¨ìˆ˜/ë³€ìˆ˜ëª…ì€ ì›ë³¸ íë¦„ ìœ ì§€) ===== */
let ocrWorker = null;   // FaceMesh ì¸ìŠ¤í„´ìŠ¤ ì €ì¥
let ocrReady = false;
let ocrBusy = false;
let faceLastResults = null;

async function ensureOcr(){
  if(ocrReady) return;
  try{
    if(typeof FaceMesh !== 'function'){
      throw new Error('MediaPipe FaceMeshê°€ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
    }
    const faceMesh = new FaceMesh({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
    });

    faceMesh.setOptions({
      maxNumFaces: 1,
      refineLandmarks: true,
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5
    });

    faceMesh.onResults((res)=>{ faceLastResults = res; });
    ocrWorker = faceMesh;
    ocrReady = true;
    log('ğŸ™‚ ì–¼êµ´ ì¸ì‹ ì¤€ë¹„ ì™„ë£Œ');
  }catch(e){
    log('âŒ ì–¼êµ´ ì¸ì‹ ì´ˆê¸°í™” ì‹¤íŒ¨: '+e);
  }
}

/* ROI ì¢Œí‘œ(í™”ë©´ ì¤‘ì•™) */
function getRoiRectFromFocus(video, fracW=0.7, fracH=0.7){
  const vw = Math.max(1, video.videoWidth || 320);
  const vh = Math.max(1, video.videoHeight|| 240);
  const rw = Math.round(vw * fracW);
  const rh = Math.round(vh * fracH);
  const x0 = Math.max(0, Math.floor((vw - rw)/2));
  const y0 = Math.max(0, Math.floor((vh - rh)/2));
  return { x:x0, y:y0, w:rw, h:rh, vw, vh };
}

/* ROI ì´ë¯¸ì§€ ëŒ€ë¹„/ê°ë§ˆ ë³´ì •(ì›ë³¸ í•¨ìˆ˜ íë¦„ ìœ ì§€) */
function enhanceCanvasForHands(mode){
  try{
    const img = ocrCtx.getImageData(0,0, OCR_W, OCR_H);
    const d = img.data;
    const hist = new Uint32Array(256);

    for(let i=0;i<d.length;i+=4){
      const y = (d[i]*0.299 + d[i+1]*0.587 + d[i+2]*0.114) | 0;
      hist[y]++;
    }

    const total = OCR_W * OCR_H;
    const lowCount  = Math.max(1, Math.floor(total * 0.01));
    const highCount = Math.max(1, Math.floor(total * 0.99));

    let cum=0, low=0, high=255;
    for(let i=0;i<256;i++){
      cum += hist[i];
      if(cum >= lowCount){ low=i; break; }
    }
    cum=0;
    for(let i=0;i<256;i++){
      cum += hist[i];
      if(cum >= highCount){ high=i; break; }
    }
    if(high <= low + 8){ low=0; high=255; }

    const scale = 255 / Math.max(1, (high - low));
    const gamma = (mode===2 ? 0.78 : 0.88);

    for(let i=0;i<d.length;i+=4){
      const r=d[i], g=d[i+1], b=d[i+2];
      const y = (r*0.299 + g*0.587 + b*0.114);
      let ny = (y - low) * scale;
      if(ny<0) ny=0; else if(ny>255) ny=255;

      ny = 255 * Math.pow(ny/255, gamma);

      let ratio = (y>0.0001) ? (ny / y) : 0;
      if(ratio > 3.0) ratio = 3.0;

      d[i]   = Math.max(0, Math.min(255, r*ratio));
      d[i+1] = Math.max(0, Math.min(255, g*ratio));
      d[i+2] = Math.max(0, Math.min(255, b*ratio));
      d[i+3] = 255;
    }

    ocrCtx.putImageData(img,0,0);
  }catch(_e){}
}

/* ROI ì „ì²˜ë¦¬ */
function preprocessToOcrCanvas(video, rect, enhanceMode){
  ocrCtx.drawImage(video, rect.x, rect.y, rect.w, rect.h, 0, 0, OCR_W, OCR_H);
  if(enhanceMode === 1 || enhanceMode === 2){
    enhanceCanvasForHands(enhanceMode);
  }
  return {};
}

/* ================= ì–¼êµ´ ë°©í–¥ ë¶„ë¥˜ ================= */
/* í‘œì‹œê°€ ì¢Œìš° ë°˜ì „(scaleX(-1))ì´ë¯€ë¡œ, íŒì •ë„ í™”ë©´ ê¸°ì¤€ìœ¼ë¡œ ë§ì¶”ê¸° ìœ„í•´ xë¥¼ ë¯¸ëŸ¬ë§í•´ì„œ ì‚¬ìš© */
function lmMirrored(lm){
  return { x: 1 - (lm.x||0), y: (lm.y||0), z: (lm.z||0) };
}
function lmSafe(lms, idx){
  const p = lms && lms[idx];
  if(!p) return null;
  return lmMirrored(p);
}
function pxDist(a,b,vw,vh){
  const dx = (a.x-b.x)*vw;
  const dy = (a.y-b.y)*vh;
  return Math.hypot(dx,dy);
}
function faceDistanceInfo(lms, vw, vh){
  const le = lmSafe(lms, 33);
  const re = lmSafe(lms, 263);
  if(!le || !re){
    return {cat:'UNKNOWN', text:'ì¸ì‹ ê°€ëŠ¥ ê±°ë¦¬', eyeDist:0};
  }
  const d = pxDist(le,re,vw,vh);
  if(d < FACE_FAR_EYE_DIST)  return {cat:'FAR',  text:'ë©€ë¦¬ ìˆìŒ',       eyeDist:d};
  if(d > FACE_NEAR_EYE_DIST) return {cat:'NEAR', text:'ê°€ê¹Œì´ ìˆìŒ',     eyeDist:d};
  return {cat:'OK', text:'ì¸ì‹ ê°€ëŠ¥ ê±°ë¦¬', eyeDist:d};
}
function clamp01(v){ return Math.max(0, Math.min(1, v)); }

function classifyFaceDirectionFromLandmarks(lms, vw, vh){
  const nose = lmSafe(lms, 1) || lmSafe(lms, 4) || lmSafe(lms, 5) || lmSafe(lms, 195);
  const lc   = lmSafe(lms, 234);
  const rc   = lmSafe(lms, 454);
  const fh   = lmSafe(lms, 10);
  const ch   = lmSafe(lms, 152);

  if(!nose || !lc || !rc || !fh || !ch) return null;

  // yaw: ì½”ê°€ ì–‘ ë³¼ ì‚¬ì´ì—ì„œ ì–¼ë§ˆë‚˜ ì¹˜ìš°ì³¤ëŠ”ì§€ (í™”ë©´ ê¸°ì¤€)
  const denom = (rc.x - lc.x);
  let yaw = 0; // -1..1 (ìŒìˆ˜: ì™¼ìª½, ì–‘ìˆ˜: ì˜¤ë¥¸ìª½)
  if(Math.abs(denom) > 1e-4){
    const pos = (nose.x - lc.x) / denom;   // 0..1
    yaw = (pos - 0.5) * 2;                // -1..1
    yaw = Math.max(-1, Math.min(1, yaw));
  }
  const yawStrength = Math.abs(yaw);

  // pitch: í„±/ì´ë§ˆ z ì°¨ì´ë¡œ ìœ„/ì•„ë˜ ì¶”ì • (MediaPipe zëŠ” ìƒëŒ€ê°’)
  const dz = (ch.z - fh.z);
  const pitchStrength = clamp01(Math.abs(dz) / Math.max(1e-6, PITCH_Z_SCALE));

  // ê²°ì •(5ê°€ì§€): ì •ë©´/ìœ„/ì•„ë˜/ì™¼ìª½/ì˜¤ë¥¸ìª½
  let code='F_FRONT', label='ì •ë©´';
  let strength = clamp01(1 - Math.max(yawStrength, pitchStrength));

  const pitchThNorm = clamp01(PITCH_Z_TH / Math.max(1e-6, PITCH_Z_SCALE));

  if(yawStrength >= YAW_TH || pitchStrength >= pitchThNorm){
    if(yawStrength >= pitchStrength){
      if(yaw < -YAW_TH){ code='F_LEFT';  label='ì™¼ìª½';  strength = clamp01(yawStrength); }
      else if(yaw >  YAW_TH){ code='F_RIGHT'; label='ì˜¤ë¥¸ìª½'; strength = clamp01(yawStrength); }
      else { code='F_FRONT'; label='ì •ë©´'; strength = clamp01(1 - Math.max(yawStrength, pitchStrength)); }
    }else{
      if(dz < -PITCH_Z_TH){ code='F_UP';   label='ìœ„';   strength = clamp01(pitchStrength); }
      else if(dz > PITCH_Z_TH){ code='F_DOWN'; label='ì•„ë˜'; strength = clamp01(pitchStrength); }
      else { code='F_FRONT'; label='ì •ë©´'; strength = clamp01(1 - Math.max(yawStrength, pitchStrength)); }
    }
  }

  const dist = faceDistanceInfo(lms, vw, vh);
  const sizeScore = (dist.cat==='OK') ? 1 : (dist.cat==='UNKNOWN' ? 0.75 : 0.6);

  // conf: ë°©í–¥ ê°•ë„ + ê±°ë¦¬(ê°€ê¹Œì›€/ë©€ì–´ì§)ì— ëŒ€í•œ ê°€ì¤‘ì¹˜
  const conf = clamp01(0.75*strength + 0.25*sizeScore) * 100;

  return {
    code, label,
    conf,
    distanceText: dist.text,
    distanceCat: dist.cat,
    eyeDist: dist.eyeDist,
    _yaw: yaw,
    _dz: dz
  };
}

/* ì–¼êµ´ ì¸ì‹ í•œ ë²ˆ ìˆ˜í–‰ (í•¨ìˆ˜ëª… runOcrOnVideo ìœ ì§€) */
async function runOcrOnVideo(video, fullFrame=false){
  if(!ocrReady) return {status:'not-ready', distanceText:'â€”'};
  if(!video || !video.videoWidth || !video.videoHeight) return {status:'no-frame', distanceText:'â€”'};
  if(ocrBusy) return {status:'busy', distanceText:'â€”'};

  const rect = fullFrame
    ? {x:0,y:0,w:Math.max(1,video.videoWidth||320),h:Math.max(1,video.videoHeight||240)}
    : getRoiRectFromFocus(video);

  ocrBusy = true;
  try{
    // 1) ì›ë³¸ ROIë¡œ ì‹œë„
    preprocessToOcrCanvas(video, rect, 0);
    faceLastResults = null;
    await ocrWorker.send({ image: ocrCvs });
    let r = faceLastResults;

    // 2) ì–¼êµ´ì´ ì•ˆ ì¡íˆë©´ â†’ ì•½í•œ ë³´ì •
    if(!r || !r.multiFaceLandmarks || !r.multiFaceLandmarks.length){
      preprocessToOcrCanvas(video, rect, 1);
      faceLastResults = null;
      await ocrWorker.send({ image: ocrCvs });
      r = faceLastResults;
    }

    // 3) ê·¸ë˜ë„ ì•ˆ ì¡íˆë©´ â†’ ê°•í•œ ë³´ì •
    if(!r || !r.multiFaceLandmarks || !r.multiFaceLandmarks.length){
      preprocessToOcrCanvas(video, rect, 2);
      faceLastResults = null;
      await ocrWorker.send({ image: ocrCvs });
      r = faceLastResults;
    }

    ocrBusy = false;

    if(!r || !r.multiFaceLandmarks || !r.multiFaceLandmarks.length){
      return {status:'no-face', distanceText:'ì–¼êµ´ ì—†ìŒ'};
    }

    const lms = r.multiFaceLandmarks[0];
    const g = classifyFaceDirectionFromLandmarks(lms, video.videoWidth, video.videoHeight);
    if(!g){
      return {status:'no-face', distanceText:'ì–¼êµ´ ì—†ìŒ'};
    }

    return {
      status:'ok',
      digit: g.label,          // UI í‘œì‹œ ê°’
      conf: g.conf,            // %
      gesture: g.code,         // ì´ë²¤íŠ¸ í‚¤
      distanceText: g.distanceText
    };
  }catch(e){
    ocrBusy = false;
    return {status:'error', error:e, distanceText:'â€”'};
  }
}

/* ì¸ì‹ ì‹¤íŒ¨ ì‚¬ìœ  */
function describeNoDigitReason(res){
  if(!res || typeof res.status!=='string') return 'ì¸ì‹ ì‹¤íŒ¨';
  switch(res.status){
    case 'no-face': return 'ì–¼êµ´ì´ ë³´ì´ì§€ ì•ŠìŒ';
    case 'no-frame': return 'ì¹´ë©”ë¼ í”„ë ˆì„ ì—†ìŒ';
    case 'not-ready': return 'ì–¼êµ´ ì¸ì‹ ì¤€ë¹„ì¤‘';
    case 'busy': return 'ì´ì „ ì¸ì‹ ì²˜ë¦¬ì¤‘';
    case 'error': return 'ì–¼êµ´ ì¸ì‹ ì˜¤ë¥˜';
    default: return 'ì¸ì‹ ì‹¤íŒ¨';
  }
}

/* ================= ì¸ì‹ íŒŒì´í”„ë¼ì¸ ================= */
let panelLastDetectTs = 0;
let overlayLastDetectTs = 0;

/* ë¡œê·¸ ê³¼ë„ ë°©ì§€(ë°©í–¥ì´ ë°”ë€Œê±°ë‚˜ 1.5ì´ˆë§ˆë‹¤ë§Œ ê¸°ë¡) */
let lastStateKey = null;   // "gesture" ë˜ëŠ” "NONE"
let lastLogTs = 0;

function handleDigitPipeline(res, source){
  const prefix = (source === 'overlay') ? '[ì „ì²´í™”ë©´]' : '[ì¹´ë©”ë¼]';

  if(!res || res.status==='busy' || res.status==='not-ready' || res.status==='no-frame'){
    return;
  }

  // ê±°ë¦¬ í‘œì‹œ(ìš”ì²­: ìƒë‹¨ ì‘ì€ ê¸€ì”¨)
  const distText = (res && res.distanceText) ? res.distanceText : (res.status==='no-face' ? 'ì–¼êµ´ ì—†ìŒ' : 'â€”');
  if(source === 'panel'){
    updateFaceDistHint(distText);
  }else{
    try{ updateOverlayFaceDistHint(distText); }catch(_){}
  }

  // íŒ¨ë„/ì˜¤ë²„ë ˆì´ í‘œì‹œê°’ ê°±ì‹ 
  if(source === 'panel'){
    if(res.status==='ok' && res.digit!=null) updateDigitReadout(res.digit);
    else updateDigitReadout(null);
  }

  // currentKey
  let currentKey = (res.status === 'ok' && res.gesture) ? String(res.gesture) : 'NONE';
  const now = performance.now();
  const shouldLog = (currentKey !== lastStateKey) || (now - lastLogTs > 1500);

  if(shouldLog){
    lastStateKey = currentKey;
    lastLogTs = now;

    if(currentKey === 'NONE'){
      const reason = describeNoDigitReason(res);
      log(`${prefix} â‘  ì–¼êµ´ë°©í–¥ ì¸ì‹: ì—†ìŒ (${reason})`);
      return;
    }

    const label = (res.digit != null ? String(res.digit) : eventLabelFromCode(res.gesture));
    const conf  = typeof res.conf === 'number' ? res.conf : 0;

    log(`${prefix} â‘  ì–¼êµ´ë°©í–¥ ì¸ì‹: ${label} (${conf.toFixed(1)}%)`);
    log(`${prefix}    ê±°ë¦¬: ${distText}`);
    log(`${prefix} â‘¡ ì´ë²¤íŠ¸ í™•ì¸ì¤‘: ${label}`);
  }

  // ì¸ì‹ ì„±ê³µì´ ì•„ë‹ˆë©´ ì¢…ë£Œ
  if(res.status !== 'ok' || !res.gesture){
    return;
  }

  const conf  = typeof res.conf === 'number' ? res.conf : 0;

  if(conf < EVENT_CONF_MIN){
    if(shouldLog){
      log(`${prefix} âš ï¸ ì‹ ë¢°ë„ ${conf.toFixed(1)}% ë¡œ ${EVENT_CONF_MIN}% ë¯¸ë§Œì´ë¼ ì´ë²¤íŠ¸ë¥¼ ì‹¤í–‰í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.`);
    }
    return;
  }

  // â˜… ì´ë²¤íŠ¸ ì‹¤í–‰ ì¤‘ì—ëŠ” ì¸ì‹/íŠ¸ë¦¬ê±° ì¤‘ì§€ (ìš”ì²­) â˜…
  if(queueBusy) return;

  // â˜… 0.5ì´ˆ ë‹¨ìœ„ë¡œ ê³„ì† ì¸ì‹ â†’ ì´ë²¤íŠ¸ ì‹¤í–‰ (ê°™ì€ ë°©í–¥ë„ ë°˜ë³µ ì‹¤í–‰ ê°€ëŠ¥) â˜…
  triggerEvent(String(res.gesture), conf, source);
}

/* íŒ¨ë„ ê°ì§€ ë£¨í”„ */
function startDetectLoop(){
  panelLastDetectTs = 0;
  if(focusBox){
    focusBox.style.left='50%';
    focusBox.style.top ='50%';
    focusBox.style.opacity='.18';
  }

  const step = async ()=>{
    if(!camOn || camVideo.readyState < 2){
      camRAF = requestAnimationFrame(step);
      return;
    }

    const allowPanelOcr = !isFullscreenRun;

    // â˜… ì´ë²¤íŠ¸ ì‹¤í–‰ ì¤‘ì—ëŠ” ì¸ì‹ ì¤‘ì§€(í í­ì£¼ ë°©ì§€) â˜…
    if(allowPanelOcr && !queueBusy){
      const now = performance.now();
      if(now - panelLastDetectTs >= DETECT_PERIOD_MS){
        panelLastDetectTs = now;
        const res = await runOcrOnVideo(camVideo, false);
        handleDigitPipeline(res, 'panel');
      }
    }

    camRAF = requestAnimationFrame(step);
  };

  camRAF = requestAnimationFrame(step);
}

/* ================= ì „ì²´í™”ë©´ ì¸ì‹ ================= */
const overlayEl = document.getElementById('playOverlay');
const overlayDigitBadge = document.getElementById('overlayDigitBadge');
const overlayDigitVal   = overlayDigitBadge.querySelector('.value');
const eyesCam = document.getElementById('eyesCam');
const ovFaceDistHintEl = document.getElementById('ovFaceDistHint');

function updateOverlayFaceDistHint(v){
  if(ovFaceDistHintEl) ovFaceDistHintEl.textContent = (v==null ? 'â€”' : String(v));
}

const ovEyes   = [...document.querySelectorAll('#playOverlay .eye')];
const ovPupils = [...document.querySelectorAll('#playOverlay .pupil')];

let eyesRAF = null;
let overlayBlinkTimer = null;

let ovCurrent = {x:0, y:0};
let ovTarget  = {x:0, y:0};

/* ëˆˆêº¼í’€ ê¹œë¹¡ì„ */
function scheduleOverlayBlink(){
  clearTimeout(overlayBlinkTimer);
  const t = 2200 + Math.random()*3300;
  overlayBlinkTimer = setTimeout(()=>{
    ovEyes.forEach(e=>{
      e.classList.add('blink');
      setTimeout(()=> e.classList.remove('blink'),
        parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--blinkSpeed')) + 40);
    });
    scheduleOverlayBlink();
  }, t);
}

/* ë™ê³µ ë Œë” */
function renderPupils(nx, ny){
  ovEyes.forEach((eye, i) => {
    const rect = eye.getBoundingClientRect();
    const rEye = Math.min(rect.width, rect.height)/2;
    const limit = rEye * 0.32;
    let dx = nx * limit, dy = ny * limit;
    const dist = Math.hypot(dx,dy);
    if (dist>limit){
      const r = limit/dist;
      dx*=r; dy*=r;
    }
    ovPupils[i].style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
  });
}

/* ë°°ì§€ ê°±ì‹  */
function overlayShowDigit(d){
  if(!overlayDigitBadge) return;
  overlayDigitVal.textContent = (d==null || d==='') ? 'â€”' : String(d);
  overlayDigitBadge.style.display = 'inline-flex';
}

/* í„°ì¹˜/ë“œë˜ê·¸ë¡œ ì‹œì„  ì´ë™ */
let overlayPointerIdleTimer = null;
function setOverlayTarget(nx,ny){
  ovTarget.x = Math.max(-1, Math.min(1,nx));
  ovTarget.y = Math.max(-1, Math.min(1,ny));
}
function handleOverlayPointer(e){
  const pt = ('touches' in e && e.touches[0]) ? e.touches[0] : e;
  const cx = innerWidth/2, cy = innerHeight/2;
  const dx = pt.clientX - cx, dy = pt.clientY - cy;
  const d = Math.hypot(innerWidth, innerHeight) || 1;
  setOverlayTarget(dx/(d*0.25), dy/(d*0.25));
  clearTimeout(overlayPointerIdleTimer);
  overlayPointerIdleTimer = setTimeout(()=> { setOverlayTarget(0,0); }, 900);
}

/* ë”ë¸” íƒ­/í´ë¦­ ì¢…ë£Œ */
let lastTap=0;
function onOverlayPointerDown(e){
  const now = e.timeStamp || Date.now();
  if (now - lastTap <= 300){
    stopRun();
    lastTap = 0;
  }else{
    lastTap = now;
  }
}
function onOverlayDblClick(){ stopRun(); }

/* ì˜¤ë²„ë ˆì´ ë£¨í”„ */
async function startOverlayEyes(){
  if(eyesRAF){ cancelAnimationFrame(eyesRAF); eyesRAF = null; }
  overlayShowDigit(null);
  updateOverlayFaceDistHint('â€”');
  overlayLastDetectTs = 0;

  try{
    if(camStream){
      eyesCam.srcObject = camStream;
      const p = eyesCam.play();
      if(p && typeof p.then==='function') await p;
    }
  }catch(e){}

  scheduleOverlayBlink();
  overlayEl.addEventListener('pointermove', handleOverlayPointer);
  overlayEl.addEventListener('pointerdown', handleOverlayPointer);
  overlayEl.addEventListener('pointerdown', onOverlayPointerDown);
  overlayEl.addEventListener('dblclick', onOverlayDblClick);

  const loop = async ()=>{
    if(!isRunning || !isFullscreenRun){
      eyesRAF = requestAnimationFrame(loop);
      return;
    }
    if(!eyesCam || eyesCam.readyState < 2){
      eyesRAF = requestAnimationFrame(loop);
      return;
    }

    // â˜… ì´ë²¤íŠ¸ ì‹¤í–‰ ì¤‘ì—ëŠ” ì¸ì‹ ì¤‘ì§€(ìš”ì²­) â˜…
    if(!queueBusy){
      const now = performance.now();
      if(now - overlayLastDetectTs >= DETECT_PERIOD_MS){
        overlayLastDetectTs = now;
        const res = await runOcrOnVideo(eyesCam, false);
        handleDigitPipeline(res, 'overlay');

        if(res && res.status==='ok' && res.digit!=null){
          overlayShowDigit(res.digit);
        }else{
          overlayShowDigit(null);
        }
      }
    }

    ovCurrent.x += (ovTarget.x - ovCurrent.x) * 0.08;
    ovCurrent.y += (ovTarget.y - ovCurrent.y) * 0.08;
    renderPupils(ovCurrent.x, ovCurrent.y);

    eyesRAF = requestAnimationFrame(loop);
  };
  eyesRAF = requestAnimationFrame(loop);
}

function stopOverlayEyes(){
  if(eyesRAF){ cancelAnimationFrame(eyesRAF); eyesRAF=null; }
  overlayShowDigit(null);
  updateOverlayFaceDistHint('â€”');
  clearTimeout(overlayBlinkTimer);
  overlayEl.removeEventListener('pointermove', handleOverlayPointer);
  overlayEl.removeEventListener('pointerdown', handleOverlayPointer);
  overlayEl.removeEventListener('pointerdown', onOverlayPointerDown);
  overlayEl.removeEventListener('dblclick', onOverlayDblClick);
}

/* ================= ë: ë©”ì¸ ìŠ¤í¬ë¦½íŠ¸ ================= */
</script>

<!-- ì¢Œìš° ìŠ¬ë¼ì´ë” / íŒŒì¼ ë©”ë‰´ -->
<script id="xrobo-hsplit-script">
(function(){
  var res = document.getElementById('hResizer');
  var main = document.getElementById('main');
  var right = document.getElementById('right');
  if(!res || !main || !right) return;

  var dragging = false;
  var startX = 0;
  var startW = 0;
  var rafId = 0;
  var maxW = 0;

  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

  function computeMax(){
    var rect = main.getBoundingClientRect();
    var barW = res.getBoundingClientRect().width || 8;
    maxW = Math.max(0, rect.width - barW);
    return maxW;
  }

  function onDown(clientX){
    dragging = true;
    startX = clientX;
    startW = right.getBoundingClientRect().width;
    computeMax();
    document.body.classList.add('hs-resizing');
  }

  function applyWidth(newW){
    newW = clamp(newW, 0, maxW);
    document.documentElement.style.setProperty('--rightW', newW + 'px');
    cancelAnimationFrame(rafId);
    rafId = requestAnimationFrame(function(){
      try{
        if (window.Blockly && typeof Blockly.svgResize==='function' && window.ws){
          Blockly.svgResize(ws);
        }
      }catch(e){}
    });
  }

  function onMove(clientX){
    if(!dragging) return;
    var dx = clientX - startX;
    var newW = startW - dx;
    applyWidth(newW);
  }

  function onUp(){
    dragging = false;
    document.body.classList.remove('hs-resizing');
  }

  res.addEventListener('mousedown', function(e){
    e.preventDefault();
    onDown(e.clientX);
  });
  window.addEventListener('mousemove', function(e){ onMove(e.clientX); });
  window.addEventListener('mouseup', onUp);

  res.addEventListener('touchstart', function(e){
    if(!e.touches || !e.touches[0]) return;
    e.preventDefault();
    onDown(e.touches[0].clientX);
  }, {passive:false});
  window.addEventListener('touchmove', function(e){
    if(!e.touches || !e.touches[0]) return;
    onMove(e.touches[0].clientX);
  }, {passive:false});
  window.addEventListener('touchend', onUp);

  document.body.classList.remove('panel-collapsed');

  window.addEventListener('resize', function(){
    var cur = right.getBoundingClientRect().width;
    var mx = computeMax();
    if(cur > mx) applyWidth(mx);
  });
})();

/* === íŒŒì¼ ë“œë¡­ë‹¤ìš´ ë¡œì§(ì €ì¥/ë¶ˆëŸ¬ì˜¤ê¸°) === */
(function(){
  var btn  = document.getElementById('fileBtn');
  var menu = document.getElementById('fileMenu');
  if(!btn || !menu) return;
  btn.addEventListener('click', function(e){
    e.stopPropagation();
    menu.classList.toggle('show');
    menu.setAttribute('aria-hidden', menu.classList.contains('show') ? 'false' : 'true');
  });
  document.addEventListener('click', function(){
    menu.classList.remove('show');
    menu.setAttribute('aria-hidden','true');
  });
  menu.addEventListener('click', function(e){
    var t = e.target;
    if(!t || !t.getAttribute) return;
    var cmd = t.getAttribute('data-cmd');
    if(!cmd) return;
    try{
      if(cmd==='save'){ if(typeof saveProject==='function') saveProject(); }
      else if(cmd==='load'){ if(typeof loadProject==='function') loadProject(); }
    }catch(_){}
    menu.classList.remove('show');
    menu.setAttribute('aria-hidden','true');
  });
})();
</script>

<!-- === ìƒˆë¡œë§Œë“¤ê¸° ì „ìš© ì•ˆì „ ë°”ì¸ë”© === -->
<script>
(function(){
  var menu = document.getElementById('fileMenu');
  if(!menu) return;
  if(menu.__x_new_bound) return;
  menu.__x_new_bound = true;
  menu.addEventListener('click', function(e){
    try{
      var cmd = e && e.target && e.target.getAttribute && e.target.getAttribute('data-cmd');
      if(cmd !== 'new') return;
      if (typeof ws !== 'undefined' && ws && typeof ws.clear === 'function'){
        if(confirm('í˜„ì¬ í”„ë¡œì íŠ¸ë¥¼ ëª¨ë‘ ì§€ìš°ê³  ìƒˆë¡œ ë§Œë“¤ê¹Œìš”?')){
          try{ ws.clear(); }catch(_){}
          try{
            if(typeof multiServoConfigs !== 'undefined' &&
               multiServoConfigs &&
               typeof multiServoConfigs.clear==='function'){
              multiServoConfigs.clear();
            }
          }catch(_){}
          try{ if(typeof refreshCodeDebounced === 'function') refreshCodeDebounced(); }catch(_){}
          try{ if(typeof log === 'function') log('ğŸ†• ìƒˆ í”„ë¡œì íŠ¸'); }catch(_){}
        }
      }else{
        if(confirm('í˜ì´ì§€ë¥¼ ìƒˆë¡œê³ ì¹¨í•˜ì—¬ ìƒˆë¡œ ì‹œì‘í• ê¹Œìš”?')){
          location.reload();
        }
      }
    }catch(_){}
  });
})();
</script>

<!-- ì•ˆë“œë¡œì´ë“œ ìˆ«ì í‚¤íŒ¨ë“œ (ì›ë³¸ ìœ ì§€) -->
<script id="xrobo-kp4x4-v14-script">
(function(){
  if(!/Android/i.test(navigator.userAgent||'')) { return; }

  'use strict';
  const isAndroid = /Android/i.test(navigator.userAgent||'');
  if(!isAndroid){ return; }
  const hasPointer = 'PointerEvent' in window;

  let pad, disp, grid;
  let activeInput = null;
  let activeField = null;
  let promptCallback = null;
  let buffer = '';
  let rafId = 0;
  let lastAnchor = {x: window.innerWidth/2, y: 140};
  let outsideBound = false;
  let committing = false;

  let lastPressLabel = '';
  let lastPressTime = 0;
  const PRESS_DEBOUNCE_MS = 160;

  function safeEval(expr){
    if(typeof expr!=='string') return NaN;
    expr = expr.replace(/[^0-9+\-*/\s]/g,'').trim();
    if(!expr) return NaN;
    const tokens = expr.match(/(\d+|[+\-*/])/g) || [];
    if(tokens.length===0) return NaN;
    const values=[], ops=[]; let expectNum=true, unary=null;
    function prec(op){ return (op==='*'||op==='/')?2:1; }
    function apply(){
      const op=ops.pop(), b=values.pop(), a=values.pop();
      values.push(op==='+'?a+b: op==='-'?a-b: op==='*'?a*b: (b===0?0:Math.trunc(a/b)));
    }
    for(const tk of tokens){
      if(/^\d+$/.test(tk)){
        let v=parseInt(tk,10);
        if(unary==='-') v=-v;
        unary=null;
        values.push(v);
        expectNum=false;
      }else{
        if(expectNum){
          if(tk==='+'||tk==='-') unary=tk;
        }else{
          while(ops.length && prec(ops[ops.length-1])>=prec(tk)) apply();
          ops.push(tk);
          expectNum=true;
        }
      }
    }
    while(ops.length) apply();
    return values.length? values[0]:NaN;
  }
  function dispatch(el, type){
    try{ el.dispatchEvent(new Event(type, {bubbles:true})); }catch(_){}
  }

  function buildPad(){
    if(pad) return pad;
    pad = document.createElement('div');
    pad.id = 'xrobo-kp4x4-v14';
    pad.innerHTML = '<div class="display" aria-live="polite"></div><div class="grid" role="group" aria-label="ìˆ«ìíŒ¨ë“œ"></div>';
    document.body.appendChild(pad);
    disp = pad.querySelector('.display');
    grid = pad.querySelector('.grid');

    const layout = [
      {t:'1'},{t:'2'},{t:'3'},{t:'â†',cls:'back'},
      {t:'4'},{t:'5'},{t:'6'},{t:'C',cls:'clear'},
      {t:'7'},{t:'8'},{t:'9'},{t:'+',cls:'op'},
      {t:'*',cls:'op'},{t:'0'},{t:'/',cls:'op'},{t:'-',cls:'op'},
      {t:'í™•ì¸',cls:'wide ok'},{t:'ì·¨ì†Œ',cls:'wide cancel'}
    ];
    layout.forEach(k=>{
      const b=document.createElement('button');
      b.type='button';
      b.textContent=k.t;
      if(k.cls) k.cls.split(' ').forEach(c=>b.classList.add(c));
      grid.appendChild(b);
    });

    const press = (label)=>{
      const now = performance.now();
      if(label === lastPressLabel && (now - lastPressTime) < PRESS_DEBOUNCE_MS){
        return;
      }
      lastPressLabel = label;
      lastPressTime = now;

      if(label==='í™•ì¸'){ commit(); return; }
      if(label==='ì·¨ì†Œ'){ cancel(); return; }
      if(label==='C'){ buffer=''; sync(); return; }
      if(label==='â†'){ buffer = buffer.slice(0, buffer.length-1); sync(); return; }
      if(/^[0-9+\-*/]$/.test(label)){ buffer += label; sync(); return; }
    };

    function getButtonFromEvent(e){
      if(e.type==='touchstart' && e.touches && e.touches[0]){
        const t=e.touches[0];
        const el=document.elementFromPoint(t.clientX, t.clientY);
        return el && el.closest && el.closest('button');
      }
      return e.target && e.target.closest && e.target.closest('button');
    }

    const onPress = (e)=>{
      const btn = getButtonFromEvent(e);
      if(!btn) return;
      e.preventDefault();
      e.stopPropagation();
      press(btn.textContent);
    };

    if(!grid.dataset.bound){
      if(hasPointer){
        grid.addEventListener('pointerdown', onPress, true);
      }else if('ontouchstart' in window){
        grid.addEventListener('touchstart', onPress, {passive:false, capture:true});
      }else{
        grid.addEventListener('mousedown', onPress, true);
      }
      grid.addEventListener('click', function(e){
        e.preventDefault();
        e.stopPropagation();
      }, true);
      grid.dataset.bound = '1';
    }

    const outside = (e)=>{
      if(!pad.classList.contains('show')) return;
      if(pad.contains(e.target)) return;
      if(activeInput && e.target===activeInput) return;
      commit();
    };
    if(!outsideBound){
      if(hasPointer){
        document.addEventListener('pointerdown', outside, true);
      }else if('ontouchstart' in window){
        document.addEventListener('touchstart', outside, {passive:false, capture:true});
      }else{
        document.addEventListener('mousedown', outside, true);
      }
      outsideBound = true;
    }

    return pad;
  }

  function showPad(){ buildPad().classList.add('show'); }
  function hidePad(){ if(pad) pad.classList.remove('show'); }

  function positionNearRect(r){
    const br = pad.getBoundingClientRect();
    const pw=br.width, ph=br.height;
    const gap=8, vx=window.scrollX||0, vy=window.scrollY||0;
    let left=r.right + gap + vx, top=r.top + vy;
    if(left + pw > vx + innerWidth - 6){
      left = r.left + vx - pw - gap;
    }
    if(top + ph > vy + innerHeight - 6){
      top = Math.max(vy+6, vy + innerHeight - ph - 6);
    }
    if(top < vy + 6) top = vy + 6;
    pad.style.left = left + 'px';
    pad.style.top = top + 'px';
  }
  function positionNearInput(input){ positionNearRect(input.getBoundingClientRect()); }
  function positionNearPoint(x,y){ positionNearRect({left:x, right:x, top:y, bottom:y, width:0, height:0}); }
  function positionNearField(field){
    try{
      const root = field && field.getClickTarget_ ? field.getClickTarget_() :
                   (field && field.getSvgRoot && field.getSvgRoot());
      if(root && root.getBoundingClientRect){
        positionNearRect(root.getBoundingClientRect());
        return true;
      }
    }catch(_){}
    return false;
  }

  function startFollowInput(input){
    cancelAnimationFrame(rafId);
    const tick=()=>{
      if(activeInput){
        positionNearInput(input);
        rafId=requestAnimationFrame(tick);
      }
    };
    tick();
  }
  function stopFollow(){
    cancelAnimationFrame(rafId);
    rafId=0;
  }

  function sync(){
    if(disp) disp.textContent = buffer;
    if(activeInput){
      activeInput.value = buffer;
      dispatch(activeInput,'input');
    }
  }

  function evaluateAndClamp(raw, inputEl){
    let num = safeEval(String(raw||'').trim());
    if(!Number.isFinite(num)) return { ok:false, val:String(raw||'') };
    const min = Number(inputEl?.getAttribute('min'));
    const max = Number(inputEl?.getAttribute('max'));
    if(Number.isFinite(min)) num = Math.max(min, num);
    if(Number.isFinite(max)) num = Math.min(max, num);
    return { ok:true, val:String(num) };
  }

  function commit(){
    if(committing) return;
    committing = true;
    try{
      if(activeField && !activeInput){
        const { ok, val } = evaluateAndClamp(buffer, null);
        try{ activeField.setValue(ok ? val : buffer); }catch(_){}
        activeField = null;
      }else if(activeField && activeInput){
        const { ok, val } = evaluateAndClamp(buffer, activeInput);
        try{ activeField.setValue(ok ? val : buffer); }catch(_){}
        activeField = null;
      }else if(typeof promptCallback === 'function'){
        const n = safeEval(buffer);
        const v = Number.isFinite(n) ? String(n) : buffer;
        try{ promptCallback(v); }catch(_){}
        promptCallback = null;
      }else if(activeInput){
        const { ok, val } = evaluateAndClamp(buffer, activeInput);
        activeInput.value = val;
        dispatch(activeInput,'input');
        dispatch(activeInput,'change');
      }
      try{
        if(window.Blockly && Blockly.WidgetDiv &&
           typeof Blockly.WidgetDiv.hide==='function'){
          Blockly.WidgetDiv.hide();
        }
      }catch(_){}
      activeInput = null;
      stopFollow();
      hidePad();
    }finally{
      committing = false;
    }
  }

  function cancel(){
    activeField = null;
    promptCallback = null;
    activeInput = null;
    stopFollow();
    hidePad();
  }

  function findBlocklyInput(){
    try{
      if(window.Blockly){
        if(Blockly.FieldTextInput && Blockly.FieldTextInput.htmlInput_){
          return Blockly.FieldTextInput.htmlInput_;
        }
        if(Blockly.WidgetDiv && Blockly.WidgetDiv.DIV){
          const el = Blockly.WidgetDiv.DIV.querySelector('input,textarea');
          if(el) return el;
        }
      }
      const q = document.querySelector('.blocklyHtmlInput, .blocklyHtmlTextInput, input.blocklyHtmlInput');
      if(q) return q;
    }catch(_){}
    return null;
  }

  function setupInputPlatform(input){
    if(isAndroid){
      input.setAttribute('readonly', 'readonly');
      input.setAttribute('inputmode','none');
      input.addEventListener('touchstart', ev=>{
        ev.preventDefault();
        ev.stopPropagation();
      }, {capture:true, passive:false});
      setTimeout(()=>{ try{ input.blur(); }catch(_){ } }, 0);
    }else{
      input.removeAttribute('readonly');
      input.setAttribute('inputmode','numeric');
      try{ input.focus(); }catch(_){}
      input.addEventListener('keydown', function(e){
        if(e.key==='Enter'){ e.preventDefault(); commit(); }
        else if(e.key==='Escape'){ e.preventDefault(); cancel(); }
      }, {once:true, capture:true});
    }
    input.setAttribute('pattern','[0-9+\\-*/]*');
    input.setAttribute('autocomplete','off');
    input.setAttribute('autocorrect','off');
    input.setAttribute('autocapitalize','off');
    input.setAttribute('spellcheck','false');
  }

  function openForInput(input, field){
    activeInput = input;
    activeField = field || null;
    promptCallback = null;
    setupInputPlatform(input);
    buffer = String(input.value||'');
    showPad();
    positionNearInput(input);
    startFollowInput(input);
    sync();
  }

  function openForField(field){
    activeField = field || null;
    activeInput = null;
    promptCallback = null;
    buffer = (field && typeof field.getValue==='function') ? String(field.getValue()||'') : '';
    showPad();
    if(!positionNearField(field)){
      positionNearPoint(lastAnchor.x, lastAnchor.y);
    }
    sync();
  }

  function openForPrompt(defVal, anchor){
    activeInput = null;
    activeField = null;
    buffer = String(defVal||'');
    showPad();
    positionNearPoint(anchor.x, anchor.y);
    sync();
  }

  function afterEditorOpened(field){
    let found = false;
    const adopt = ()=>{
      const input = findBlocklyInput();
      if(input){
        if(!pad || !pad.classList.contains('show')) showPad();
        openForInput(input, field);
        found = true;
        return true;
      }
      return false;
    };
    if(adopt()) return;
    openForField(field);
    let tries = 0;
    const iv=setInterval(()=>{
      if(adopt() || ++tries>8) clearInterval(iv);
    },50);
  }

  function patchFieldNumber(){
    try{
      if(!window.Blockly || !Blockly.FieldNumber || Blockly.FieldNumber.__xrobo_v14) return;
      function wrap(name){
        const orig = Blockly.FieldNumber.prototype[name];
        if(!orig) return false;
        Blockly.FieldNumber.prototype[name] = function(){
          const rv = orig.apply(this, arguments);
          const self = this;
          setTimeout(()=> afterEditorOpened(self), 0);
          return rv;
        };
        return true;
      }
      wrap('showEditor_') || wrap('showEditor');
      Blockly.FieldNumber.__xrobo_v14 = true;
    }catch(_){}
  }

  function patchFieldTextInput(){
    try{
      if(!window.Blockly || !Blockly.FieldTextInput || Blockly.FieldTextInput.__xrobo_v14) return;
      const proto = Blockly.FieldTextInput.prototype;
      const origShow = proto.showEditor_;
      proto.showEditor_ = function(opt_e){
        const rv = origShow ? origShow.apply(this, arguments) : undefined;
        if((typeof Blockly.FieldNumber!=='undefined') && (this instanceof Blockly.FieldNumber)){
          const self = this;
          setTimeout(()=> afterEditorOpened(self), 0);
        }
        return rv;
      };
      const origPrompt = proto.showPromptEditor_;
      if(typeof origPrompt === 'function'){
        proto.showPromptEditor_ = function(){
          if((typeof Blockly.FieldNumber!=='undefined') && (this instanceof Blockly.FieldNumber)){
            openForPrompt(this.getValue ? this.getValue() : '', lastAnchor);
            return;
          }
          return origPrompt.apply(this, arguments);
        };
      }
      Blockly.FieldTextInput.__xrobo_v14 = true;
    }catch(_){}
  }

  function patchPrompt(){
    try{
      if(!window.Blockly) return;
      const numLike = v => /^[\s]*[+\-]?\d+(?:[\s]*[+\-*/][\s]*[+\-]?\d+)*[\s]*$/.test(String(v||''));
      if(Blockly.dialog && typeof Blockly.dialog.setPrompt==='function' && !Blockly.dialog.__xrobo_v14){
        Blockly.dialog.setPrompt(function(msg, defVal, cb){
          const looksNumeric = numLike(defVal) || /value|ê°’|number|ìˆ«ì/i.test(String(msg||''));
          if(looksNumeric){
            promptCallback = v => { try{ cb(v); }catch(_){ } };
            openForPrompt(defVal, lastAnchor);
          }else{
            const ans = window.prompt(String(msg||''), String(defVal||''));
            try{ cb(ans); }catch(_){}
          }
        });
        Blockly.dialog.__xrobo_v14 = true;
      }else if(!Blockly.__xrobo_prompt_v14){
        const old = Blockly.prompt;
        Blockly.prompt = function(message, defaultValue, callback){
          const looksNumeric = numLike(defaultValue) || /value|ê°’|number|ìˆ«ì/i.test(String(message||''));
          if(looksNumeric){
            promptCallback = v=>{ try{ callback(v); }catch(_){ }};
            openForPrompt(defaultValue, lastAnchor);
          }else{
            return old ? old.apply(this, arguments) : window.prompt(message, defaultValue);
          }
        };
        Blockly.__xrobo_prompt_v14 = true;
      }
    }catch(_){}
  }

  document.addEventListener('focusin', function(e){
    const t = e.target;
    if(!t) return;
    if(t.classList && (t.classList.contains('blocklyHtmlInput') ||
                       t.classList.contains('blocklyHtmlTextInput'))){
      openForInput(t, null);
      const onBlur = ()=>{ try{ commit(); }catch(_){ cancel(); } t.removeEventListener('blur', onBlur); };
      t.addEventListener('blur', onBlur);
    }else{
      try{
        const uaOk = /Android/i.test(navigator.userAgent||'');
        if(uaOk && t.matches('#servoModal .speedbox input, #boardStage .speedbox input')){
          try{
            t.setAttribute('inputmode','none');
            t.setAttribute('autocomplete','off');
            t.setAttribute('autocorrect','off');
          }catch(_){}
          try{
            t.setAttribute('readonly','readonly');
            setTimeout(()=>{ try{ t.removeAttribute('readonly'); }catch(_){ } }, 0);
          }catch(_){}
          openForInput(t, null);
          const onBlur = ()=>{ try{ commit(); }catch(_){ cancel(); } t.removeEventListener('blur', onBlur); };
          t.addEventListener('blur', onBlur);
        }
      }catch(_){}
    }
  }, true);

  (function(){
    if(!/Android/i.test(navigator.userAgent||'')) { return; }
    const root = document.getElementById('blocklyDiv') || document.body;
    const savePt = (e)=>{ lastAnchor = {x:e.clientX, y:e.clientY}; };
    if(hasPointer){
      root.addEventListener('pointerdown', savePt, true);
    }else{
      root.addEventListener('mousedown', savePt, true);
      root.addEventListener('touchstart', (e)=>{
        if(e.touches&&e.touches[0]) lastAnchor={x:e.touches[0].clientX, y:e.touches[0].clientY};
      }, {capture:true, passive:true});
    }
  })();

  function tryPatch(){ patchFieldNumber(); patchFieldTextInput(); patchPrompt(); }
  if(document.readyState==='complete' || document.readyState==='interactive'){
    tryPatch();
  }else{
    window.addEventListener('DOMContentLoaded', tryPatch);
  }
  let tries=0;
  const iv=setInterval(()=>{ tryPatch(); if(++tries>12) clearInterval(iv); }, 300);
})();
</script>
</body>
</html>
